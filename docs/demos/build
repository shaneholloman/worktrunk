#!/usr/bin/env python3
"""Unified build script for demo GIFs.

Usage:
    ./build docs                    # Build doc site demos (light + dark, 1600x900)
    ./build social                  # Build social media demos (light only, 1200x700)
    ./build docs --only wt-merge    # Build specific demo for docs
    ./build social --only wt-zellij-omnibus --shell  # Debug shell for social demo

Output is written to docs/static/assets/{mode}/{theme}/, ensuring docs and social
builds don't overwrite each other. The assets repo mirrors this structure.
"""

from __future__ import annotations

import argparse
import os
import subprocess
import sys
import tempfile
from concurrent.futures import ProcessPoolExecutor, as_completed
from functools import partial
from pathlib import Path

# Add docs/demos/ to path for shared library
SCRIPT_DIR = Path(__file__).parent
sys.path.insert(0, str(SCRIPT_DIR))

from shared import (  # noqa: E402
    VALIDATION_RS,
    DemoEnv,
    DemoSize,
    git,
    prepare_demo_repo,
    setup_claude_code_config,
    setup_zellij_config,
    setup_fish_config,
    check_dependencies,
    setup_demo_output,
    record_all_themes,
    SIZE_DOCS,
    SIZE_SOCIAL,
    record_text,
    build_tape_replacements,
    ensure_vhs_binary,
)

REPO_ROOT = SCRIPT_DIR.parent.parent
OUT_DIR = SCRIPT_DIR.parent / "static" / "assets"
TAPES_DIR = SCRIPT_DIR / "tapes"


# =============================================================================
# Setup Helpers
# =============================================================================


def _add_billing_branch(env: DemoEnv):
    """Add a billing branch at same commit as main (merged state)."""
    branch = "billing"
    path = env.work_base / f"acme.{branch}"
    git(["-C", str(env.repo), "worktree", "add", "-q", "-b", branch, str(path), "main"])
    git(["-C", str(path), "push", "-u", "origin", branch, "-q"])


def _add_staged_validation(env: DemoEnv):
    """Add validation.rs with staged changes to hooks branch."""
    hooks_path = env.work_base / "acme.hooks"
    if hooks_path.exists():
        new_file = hooks_path / "src" / "validation.rs"
        new_file.write_text(VALIDATION_RS)
        git(["-C", str(hooks_path), "add", "src/validation.rs"])


def _write_user_config(
    env: DemoEnv, approved_commands: list[str], commit_generation: bool = False
):
    """Write worktrunk user config."""
    config_dir = env.home / ".config" / "worktrunk"
    project_id = str(env.bare_remote).removesuffix(".git")

    content = ""
    if commit_generation:
        content += """[commit-generation]
command = "llm"
args = ["-m", "claude-haiku-4.5"]

"""
    content += f'[projects."{project_id}"]\n'
    content += f"approved-commands = {approved_commands!r}\n"

    (config_dir / "config.toml").write_text(content)


# =============================================================================
# Demo Setup Functions
# =============================================================================


def prepare_basic(env: DemoEnv):
    """Basic repo setup - no hooks, no extras."""
    prepare_demo_repo(env, REPO_ROOT)


def prepare_with_hooks(env: DemoEnv, include_deps: bool = False):
    """Standard hooks demo: dev server + cleanup + billing branch."""
    dev_cmd = "npm run dev -- --port {{ branch | hash_port }}"
    cleanup_cmd = "flyctl scale count 0"

    post_start = ["[post-start]"]
    approved = []
    if include_deps:
        post_start.append('deps = "npm install"')
        approved.append("npm install")
    post_start.append(f'dev = "{dev_cmd}"')
    approved.append(dev_cmd)
    approved.append(cleanup_cmd)

    hooks_config = (
        "\n".join(post_start) + f'\n\n[pre-remove]\ncleanup = "{cleanup_cmd}"\n'
    )

    prepare_demo_repo(env, REPO_ROOT, hooks_config=hooks_config)
    _write_user_config(env, approved)
    _add_billing_branch(env)


def prepare_merge_demo(
    env: DemoEnv, commit_generation: bool = True, staged_changes: bool = True
):
    """Merge demo setup. Use commit_generation=False for social (no LLM in GIF)."""
    prepare_demo_repo(env, REPO_ROOT)
    _write_user_config(env, ["cargo nextest run"], commit_generation=commit_generation)
    if staged_changes:
        _add_staged_validation(env)


def prepare_switch(env: DemoEnv):
    """Switch demo with Claude Code UI."""
    dev_cmd = "npm run dev -- --port {{ branch | hash_port }}"
    hooks_config = f"""[post-start]
copy = "wt step copy-ignored"
dev = "{dev_cmd}"
"""
    prepare_demo_repo(env, REPO_ROOT, hooks_config=hooks_config)
    _write_user_config(env, [dev_cmd, "wt step copy-ignored"])

    # Create .env file (gitignored) so copy-ignored has something to copy
    gitignore = env.repo / ".gitignore"
    gitignore.write_text(gitignore.read_text() + ".env\n")
    env_file = env.repo / ".env"
    env_file.write_text("DATABASE_URL=postgres://localhost/acme_dev\nAPI_KEY=dev-key-123\n")

    setup_claude_code_config(
        env,
        [
            str(env.repo),
            str(env.work_base / "acme.alpha"),
            str(env.work_base / "acme.api"),
            str(env.work_base / "acme.dashboard"),
        ],
    )


def prepare_devserver(env: DemoEnv):
    """Setup for wt-devserver demo - shows URL column in wt list."""
    dev_cmd = "npm run dev -- --port {{ branch | hash_port }}"
    hooks_config = f'''[post-start]
dev = "{dev_cmd}"

[list]
url = "http://localhost:{{{{ branch | hash_port }}}}"
'''
    prepare_demo_repo(env, REPO_ROOT, hooks_config=hooks_config)
    _write_user_config(env, [dev_cmd])

    # Override npm mock to start nc listener so URL appears active
    npm_mock = env.home / ".local" / "bin" / "npm"
    npm_mock.write_text("""#!/bin/bash
if [[ "$1" == "run" && "$2" == "dev" ]]; then
    PORT="$5"
    echo ""
    echo "  VITE v5.4.2  ready in 342 ms"
    echo ""
    echo "  ➜  Local:   http://localhost:$PORT/"
    # Start nc listener so wt list shows URL as active (not dimmed)
    nc -l "$PORT" >/dev/null 2>&1 &
fi
""")
    npm_mock.chmod(0o755)


def prepare_zellij_omnibus(env: DemoEnv):
    """Setup for wt-zellij-omnibus demo - comprehensive showcase."""
    hooks_config = """[post-start]
dev = "npm run dev -- --port {{ branch | hash_port }}"

[pre-merge]
test = "cargo nextest run"

[list]
url = "http://localhost:{{ branch | hash_port }}"
"""
    prepare_demo_repo(env, REPO_ROOT, hooks_config=hooks_config)

    # Clean up branches that might exist from previous runs (billing, feature created during demo)
    origin = env.home / "origin.git"
    for branch in ["billing", "feature"]:
        # Delete from origin if exists (ignore errors if not)
        subprocess.run(
            ["git", "-C", str(origin), "branch", "-D", branch], capture_output=True
        )

    # Enable git colors for non-TTY environments (VHS)
    git(["-C", str(env.repo), "config", "color.ui", "always"])

    # Override llm mock with different commit message for this demo
    llm_mock = env.home / ".local" / "bin" / "llm"
    llm_mock.write_text("""#!/bin/bash
sleep 0.5
echo "feat: add user settings module"
echo ""
echo "Add placeholder module for user profile settings."
""")
    llm_mock.chmod(0o755)

    # User config with LLM commit generation
    _write_user_config(
        env,
        ["npm run dev -- --port {{ branch | hash_port }}", "cargo nextest run"],
        commit_generation=True,
    )

    # Zellij + Fish configs (with --create in wsl abbreviation)
    setup_zellij_config(env, default_cwd=str(env.repo))
    setup_fish_config(env, wsl_create=True)

    # Claude Code config with pre-approved tools
    worktree_branches = ["api", "auth", "billing", "feature"]
    worktree_paths = [str(env.repo)] + [
        str(env.work_base / f"acme.{branch}") for branch in worktree_branches
    ]
    allowed_tools = [
        "Bash",
        "Read",
        "Write",
        "Edit",
        "Glob",
        "Grep",
        "Task",
        "TodoWrite",
    ]
    setup_claude_code_config(env, worktree_paths, allowed_tools)

    # Pre-create worktrees (api and auth only - billing created during demo)
    demo_env = {
        **os.environ,
        "HOME": str(env.home),
        "PATH": f"{REPO_ROOT}/target/debug:{env.home}/.local/bin:{os.environ.get('PATH', '')}",
    }

    def run_wt(args, cwd):
        result = subprocess.run(
            ["wt"] + args, cwd=str(cwd), env=demo_env, capture_output=True, text=True
        )
        if result.returncode != 0:
            raise RuntimeError(f"wt {' '.join(args)} failed: {result.stderr}")

    run_wt(["switch", "--create", "api"], env.repo)
    git(["-C", str(env.work_base / "acme.api"), "push", "-u", "origin", "api", "-q"])

    run_wt(["switch", "--create", "auth"], env.repo)
    git(["-C", str(env.work_base / "acme.auth"), "push", "-u", "origin", "auth", "-q"])

    # Return to main worktree for the demo to start
    run_wt(["switch", "main"], env.work_base / "acme.api")


# =============================================================================
# Demo Registrations
# =============================================================================

# Format: (tape_file, output_name, setup_func)
# All demos in a mode use that mode's default size.
# Note: setup_func must be a named function (not lambda) for multiprocessing.

DOCS_DEMOS = [
    ("wt-core.tape", "wt-core", prepare_with_hooks),
    ("wt-switch.tape", "wt-switch", prepare_switch),
    ("wt-list.tape", "wt-list", prepare_with_hooks),
    ("wt-commit.tape", "wt-commit", prepare_merge_demo),
    ("wt-statusline.tape", "wt-statusline", prepare_switch),
    ("wt-merge.tape", "wt-merge", prepare_merge_demo),
    ("wt-select.tape", "wt-select", prepare_basic),
    ("wt-zellij-omnibus.tape", "wt-zellij-omnibus", prepare_zellij_omnibus),
]

SOCIAL_DEMOS = [
    ("wt-switch.tape", "wt-switch", prepare_switch),
    ("wt-statusline.tape", "wt-statusline", prepare_switch),
    ("wt-list.tape", "wt-list", prepare_with_hooks),
    ("wt-list-remove.tape", "wt-list-remove", prepare_with_hooks),
    ("wt-hooks.tape", "wt-hooks", partial(prepare_with_hooks, include_deps=True)),
    ("wt-devserver.tape", "wt-devserver", prepare_devserver),
    ("wt-commit.tape", "wt-commit", prepare_merge_demo),
    (
        "wt-merge.tape",
        "wt-merge",
        partial(prepare_merge_demo, commit_generation=False, staged_changes=False),
    ),
    ("wt-select.tape", "wt-select", prepare_basic),
    ("wt-core.tape", "wt-core", prepare_with_hooks),
    ("wt-zellij-omnibus.tape", "wt-zellij-omnibus", prepare_zellij_omnibus),
]

TARGETS = {
    "docs": {
        "demos": DOCS_DEMOS,
        "size": SIZE_DOCS,
        "themes": ["light", "dark"],
    },
    "social": {
        "demos": SOCIAL_DEMOS,
        "size": SIZE_SOCIAL,
        "themes": ["light"],
    },
}


# =============================================================================
# Parallel Recording
# =============================================================================


def record_demo(
    tape_file: str,
    output_name: str,
    setup_func,
    mode_out_dir: Path,
    themes: list[str],
    demo_size: DemoSize,
    vhs_binary: str,
    text_mode: bool = False,
):
    """Record a single demo (runs in subprocess for parallel execution)."""
    tape_path = TAPES_DIR / tape_file
    if not tape_path.exists():
        raise FileNotFoundError(f"{tape_file} not found")

    # Create fresh environment in temp directory
    demo_env_dir = Path(tempfile.mkdtemp(prefix="wt-demo-"))
    setup_demo_output(demo_env_dir)
    env = DemoEnv(name=output_name, out_dir=demo_env_dir, repo_name="acme")
    setup_func(env)

    replacements = build_tape_replacements(env, REPO_ROOT)

    if text_mode:
        output_txt = mode_out_dir / f"{output_name}.txt"
        record_text(env, tape_path, output_txt, replacements, REPO_ROOT)
        print(f"✓ {output_name}: Text saved to {output_txt}")
    else:
        output_gifs = {}
        for theme in themes:
            theme_dir = mode_out_dir / theme
            theme_dir.mkdir(parents=True, exist_ok=True)
            output_gifs[theme] = theme_dir / f"{output_name}.gif"

        record_all_themes(
            env,
            tape_path,
            output_gifs,
            REPO_ROOT,
            vhs_binary=vhs_binary,
            size=demo_size,
        )
        print(f"✓ {output_name}: GIFs saved: {', '.join(themes)}")


# =============================================================================
# Main
# =============================================================================


def spawn_debug_shell(env: DemoEnv, starship_config: Path):
    """Spawn an interactive fish shell with the demo environment set up."""
    shell_env = os.environ.copy()
    shell_env.update(
        {
            "HOME": str(env.home),
            "XDG_CONFIG_HOME": str(env.home / ".config"),
            "STARSHIP_CONFIG": str(starship_config),
            "PATH": f"{REPO_ROOT / 'target' / 'debug'}:{env.home / '.local' / 'bin'}:{os.environ.get('PATH', '')}",
            # Keep real rustup/cargo for any rust tools
            "RUSTUP_HOME": str(Path.home() / ".rustup"),
            "CARGO_HOME": str(Path.home() / ".cargo"),
        }
    )

    print("\nSpawning fish shell in demo environment...")
    print(f"  HOME={env.home}")
    print(f"  Demo repo: {env.repo}\n")

    init_cmd = "starship init fish | source; wt config shell init fish | source"
    subprocess.run(["fish", "-C", init_cmd], env=shell_env, cwd=str(env.repo))


def main():
    parser = argparse.ArgumentParser(
        description="Build demo GIFs for worktrunk",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  ./build docs                    Build all doc site demos (light + dark)
  ./build social                  Build all social media demos (light only)
  ./build docs --only wt-merge    Build specific demo for docs
  ./build docs --text             Build text output instead of GIFs
  ./build social --only wt-zellij-omnibus --shell   Debug shell for demo
""",
    )
    parser.add_argument(
        "target", choices=["docs", "social"], help="Target to build demos for"
    )
    parser.add_argument("--only", help="Only record specific demo (e.g., wt-switch)")
    parser.add_argument(
        "--shell",
        action="store_true",
        help="Build demo and spawn interactive shell for debugging (requires --only)",
    )
    parser.add_argument(
        "--text", action="store_true", help="Record text output instead of GIFs"
    )
    parser.add_argument(
        "--sequential",
        action="store_true",
        help="Record demos sequentially instead of in parallel",
    )
    args = parser.parse_args()

    if args.shell and not args.only:
        print("--shell requires --only to specify which demo to debug")
        return

    if args.shell and args.text:
        print("--shell and --text are mutually exclusive")
        return

    # Check dependencies (VHS is built from source, not required in PATH)
    deps = ["wt", "starship", "zellij"]
    check_dependencies(deps)

    # Ensure VHS is built (requires Go)
    vhs_binary = str(ensure_vhs_binary())

    # Output goes to mode/theme subdirectories
    mode_out_dir = OUT_DIR / args.target
    starship_config = setup_demo_output(mode_out_dir)

    target_config = TARGETS[args.target]
    demos = target_config["demos"]
    demo_size = target_config["size"]
    themes = target_config["themes"]

    # Filter demos if --only specified
    if args.only:
        demos = [(t, n, s) for t, n, s in demos if n == args.only]
        if not demos:
            all_names = [n for _, n, _ in target_config["demos"]]
            print(f"Unknown demo: {args.only}")
            print(f"Available for {args.target}: {', '.join(all_names)}")
            return

    # Handle --shell mode (interactive, must be sequential)
    if args.shell:
        tape_file, output_name, setup_func = demos[0]
        demo_env_dir = Path(tempfile.mkdtemp(prefix="wt-demo-"))
        setup_demo_output(demo_env_dir)
        env = DemoEnv(name=output_name, out_dir=demo_env_dir, repo_name="acme")
        setup_func(env)
        print(f"Demo repo: {env.repo}")
        spawn_debug_shell(env, starship_config)
        return

    # Record demos
    if args.sequential or len(demos) == 1:
        print(f"\nRecording {len(demos)} demo(s) sequentially...")
        failed = []
        for tape_file, output_name, setup_func in demos:
            try:
                record_demo(
                    tape_file,
                    output_name,
                    setup_func,
                    mode_out_dir,
                    themes,
                    demo_size,
                    vhs_binary,
                    args.text,
                )
            except Exception as e:
                print(f"✗ {output_name}: {e}")
                failed.append(output_name)
    else:
        print(f"\nRecording {len(demos)} demo(s) in parallel...")
        max_workers = min(len(demos), os.cpu_count() or 4)

        with ProcessPoolExecutor(max_workers=max_workers) as executor:
            futures = {
                executor.submit(
                    record_demo,
                    tape_file,
                    output_name,
                    setup_func,
                    mode_out_dir,
                    themes,
                    demo_size,
                    vhs_binary,
                    args.text,
                ): output_name
                for tape_file, output_name, setup_func in demos
            }

            failed = []
            for future in as_completed(futures):
                output_name = futures[future]
                try:
                    future.result()
                except Exception as e:
                    print(f"✗ {output_name}: {e}")
                    failed.append(output_name)

    if failed:
        print(f"\n{'=' * 60}")
        print(f"Failed: {', '.join(failed)}")
        sys.exit(1)


if __name__ == "__main__":
    main()
