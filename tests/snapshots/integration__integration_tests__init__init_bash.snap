---
source: tests/integration_tests/init.rs
info:
  program: wt
  args:
    - config
    - shell
    - init
    - bash
  env:
    APPDATA: "[TEST_CONFIG_HOME]"
    CLICOLOR_FORCE: "1"
    COLUMNS: "150"
    GIT_AUTHOR_DATE: "2025-01-01T00:00:00Z"
    GIT_COMMITTER_DATE: "2025-01-01T00:00:00Z"
    GIT_CONFIG_GLOBAL: "[TEST_GIT_CONFIG]"
    GIT_CONFIG_SYSTEM: /dev/null
    GIT_EDITOR: ""
    HOME: "[TEST_HOME]"
    LANG: C
    LC_ALL: C
    PATH: "[PATH]"
    SOURCE_DATE_EPOCH: "1735776000"
    USERPROFILE: "[TEST_HOME]"
    WORKTRUNK_CONFIG_PATH: "[TEST_CONFIG]"
    XDG_CONFIG_HOME: "[TEST_CONFIG_HOME]"
---
success: true
exit_code: 0
----- stdout -----
# worktrunk shell integration for bash

# Only initialize if wt is available (in PATH or via WORKTRUNK_BIN)
if command -v wt >/dev/null 2>&1 || [[ -n "${WORKTRUNK_BIN:-}" ]]; then

# Capture stdout (shell script), eval in parent shell. stderr streams to terminal.
# WORKTRUNK_BIN can override the binary path (for testing dev builds).
wt_exec() {
    local script exit_code=0
    script="$(command "${WORKTRUNK_BIN:-wt}" "$@")" || exit_code=$?

    if [[ -n "$script" ]]; then
        eval "$script"
        if [[ $exit_code -eq 0 ]]; then
            exit_code=$?
        fi
    fi

    return "$exit_code"
}

    # Override wt command to add --internal flag
    wt() {
        local use_source=false
        local args=()

        for arg in "$@"; do
            if [[ "$arg" == "--source" ]]; then use_source=true; else args+=("$arg"); fi
        done

        # Completion mode: call binary directly, bypassing --internal and wt_exec.
        # This check MUST be here (not in the binary) because clap's completion
        # handler runs before argument parsing - we can't detect --internal there.
        # The binary outputs completion candidates, not shell script to eval.
        if [[ -n "${COMPLETE:-}" ]]; then
            command "${WORKTRUNK_BIN:-wt}" "${args[@]}"
            return
        fi

        # --source: use cargo run (builds from source)
        if [[ "$use_source" == true ]]; then
            local script exit_code=0
            script="$(cargo run --bin wt --quiet -- --internal "${args[@]}")" || exit_code=$?
            if [[ -n "$script" ]]; then
                eval "$script"
                if [[ $exit_code -eq 0 ]]; then
                    exit_code=$?
                fi
            fi
            return "$exit_code"
        fi

        wt_exec --internal "${args[@]}"
    }

    # Lazy completions - generate on first TAB, then delegate to clap's completer
    _wt_lazy_complete() {
        # Generate completions function once (check if clap's function exists)
        if ! declare -F _clap_complete_wt >/dev/null; then
            # Use `command` to bypass the shell function and call the binary directly.
            # Without this, `wt` would call the shell function which evals
            # the completion script internally but doesn't re-emit it.
            eval "$(COMPLETE=bash command "${WORKTRUNK_BIN:-wt}" 2>/dev/null)" || return
        fi
        _clap_complete_wt "$@"
    }

    complete -o nospace -o bashdefault -F _wt_lazy_complete wt
fi

----- stderr -----
