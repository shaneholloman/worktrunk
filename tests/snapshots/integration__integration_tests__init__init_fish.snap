---
source: tests/integration_tests/init.rs
info:
  program: wt
  args:
    - config
    - shell
    - init
    - fish
  env:
    APPDATA: "[TEST_CONFIG_HOME]"
    CLICOLOR_FORCE: "1"
    COLUMNS: "150"
    GIT_AUTHOR_DATE: "2025-01-01T00:00:00Z"
    GIT_COMMITTER_DATE: "2025-01-01T00:00:00Z"
    GIT_CONFIG_GLOBAL: "[TEST_GIT_CONFIG]"
    GIT_CONFIG_SYSTEM: /dev/null
    GIT_EDITOR: ""
    HOME: "[TEST_HOME]"
    LANG: C
    LC_ALL: C
    PATH: "[PATH]"
    SOURCE_DATE_EPOCH: "1735776000"
    USERPROFILE: "[TEST_HOME]"
    WORKTRUNK_CONFIG_PATH: "[TEST_CONFIG]"
    XDG_CONFIG_HOME: "[TEST_CONFIG_HOME]"
---
success: true
exit_code: 0
----- stdout -----
# worktrunk shell integration for fish

# Only initialize if wt is available (in PATH or via WORKTRUNK_BIN)
if type -q wt; or test -n "$WORKTRUNK_BIN"
    # Capture stdout (shell script), eval in parent shell. stderr streams to terminal.
    # WORKTRUNK_BIN can override the binary path (for testing dev builds).
    #
    # We use pipeline capture (`| read`) instead of command substitution (`(...)`)
    # because fish's command substitution runs in its own pipeline where stderr
    # doesn't inherit caller redirects. With pipeline capture, stderr flows through
    # normally and respects redirects like `wt --help &>file`.
    function wt_exec
        test -n "$WORKTRUNK_BIN"; or set -l WORKTRUNK_BIN (type -P wt)

        # Pipeline capture: stderr streams through, stdout captured via read
        # -z (null delimiter) ensures we capture all lines, not just the first
        command $WORKTRUNK_BIN $argv | string collect --allow-empty | read --local -z script
        set -l exit_code $pipestatus[1]

        if test -n "$script"
            eval $script
            if test $exit_code -eq 0
                set exit_code $status
            end
        end

        return $exit_code
    end

    # Override wt command to add --internal flag
    function wt
        set -l use_source false
        set -l args

        for arg in $argv
            if test "$arg" = "--source"; set use_source true; else; set -a args $arg; end
        end

        # --source: use cargo run (builds from source)
        if test $use_source = true
            cargo run --bin wt --quiet -- --internal $args | string collect --allow-empty | read --local -z script
            set -l exit_code $pipestatus[1]
            if test -n "$script"
                eval $script
                if test $exit_code -eq 0
                    set exit_code $status
                end
            end
            return $exit_code
        end

        wt_exec --internal $args
    end

    # Completions are in ~/.config/fish/completions/wt.fish (installed by `wt config shell install`)
end

----- stderr -----
