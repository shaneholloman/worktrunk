---
source: tests/integration_tests/init.rs
info:
  program: wt
  args:
    - init
    - fish
  env:
    CLICOLOR_FORCE: "1"
    GIT_AUTHOR_DATE: "2025-01-01T00:00:00Z"
    GIT_COMMITTER_DATE: "2025-01-01T00:00:00Z"
    GIT_CONFIG_GLOBAL: /dev/null
    GIT_CONFIG_SYSTEM: /dev/null
    GIT_EDITOR: ""
    LANG: C
    LC_ALL: C
    SOURCE_DATE_EPOCH: "1704067200"
---
success: true
exit_code: 0
----- stdout -----
# worktrunk shell integration for fish

# Only initialize if wt is available
if type -q wt
    # Use WORKTRUNK_BIN if set, otherwise default to 'wt'
    # This allows testing development builds: set -x WORKTRUNK_BIN ./target/debug/wt
    if set -q WORKTRUNK_BIN
        set -g _WORKTRUNK_CMD $WORKTRUNK_BIN
    else
        set -g _WORKTRUNK_CMD wt
    end

    # Helper function to parse wt output and handle directives
    # Directives are NUL-terminated to support multi-line commands
    #
    # Note: Uses psub for process substitution to preserve NUL bytes.
    # This is reliable for simple read-only cases but psub has known
    # limitations in complex scenarios (see fish-shell issue #1040).
    # Current usage is safe as we only read from psub output sequentially.
    function _wt_exec
        set -l exec_cmd ""
        set -l exit_code_file (mktemp)
        or begin
            echo "Failed to create temp file" >&2
            return 1
        end

        # Use psub (process substitution) to preserve NUL bytes
        # Command substitution $(...)  strips NUL bytes, but psub preserves them
        # Redirect directly from psub output, and save exit code to temp file
        while read -z chunk
            if string match -q '__WORKTRUNK_CD__*' -- $chunk
                # CD directive - extract path and change directory
                set -l path (string replace '__WORKTRUNK_CD__' '' -- $chunk)
                if not cd $path
                    echo "Error: Failed to change directory to $path" >&2
                end
            else if string match -q '__WORKTRUNK_EXEC__*' -- $chunk
                # EXEC directive - extract command (may contain newlines)
                set exec_cmd (string replace '__WORKTRUNK_EXEC__' '' -- $chunk)
            else if test -n "$chunk"
                # Regular output - print it (preserving newlines)
                printf '%s' $chunk
            end
        end < (begin; command $_WORKTRUNK_CMD $argv 2>&1; echo $status > $exit_code_file; end | psub)

        # Read exit code from temp file
        set -l exit_code (cat $exit_code_file 2>/dev/null; or echo 0)
        rm -f $exit_code_file

        # Execute command if one was specified
        # Exit code semantics: Returns wt's exit code, not the executed command's.
        # This allows detecting wt failures (e.g., branch creation errors).
        # The executed command runs for side effects; its failure is logged but doesn't affect exit code.
        if test -n "$exec_cmd"
            if not eval $exec_cmd
                echo "Warning: Command execution failed (exit code $status)" >&2
            end
        end

        return $exit_code
    end

    # Override wt command to add --internal flag for switch, remove, and merge
    function wt
        set -l subcommand $argv[1]

        switch $subcommand
            case switch remove merge
                # Commands that need --internal for directory change support
                _wt_exec $subcommand --internal $argv[2..-1]
            case '*'
                # All other commands pass through directly
                command $_WORKTRUNK_CMD $argv
        end
    end

    # Dynamic completion function
    function __wt_complete
        # Call wt complete with current command line
        set -l cmd (commandline -opc)
        command $_WORKTRUNK_CMD complete $cmd 2>/dev/null
    end

    # Register dynamic completions
    complete -c wt -n '__fish_seen_subcommand_from switch' -f -a '(__wt_complete)' -d 'Branch'
    complete -c wt -n '__fish_seen_subcommand_from push' -f -a '(__wt_complete)' -d 'Target branch'
    complete -c wt -n '__fish_seen_subcommand_from merge' -f -a '(__wt_complete)' -d 'Target branch'
end

# Static completions (commands and flags)
# Print an optspec for argparse to handle cmd's options that are independent of any subcommand.
function __fish_wt_global_optspecs
	string join \n h/help V/version
end

function __fish_wt_needs_command
	# Figure out if the current invocation already has a command.
	set -l cmd (commandline -opc)
	set -e cmd[1]
	argparse -s (__fish_wt_global_optspecs) -- $cmd 2>/dev/null
	or return
	if set -q argv[1]
		# Also print the command, so this can be used to figure out what it is.
		echo $argv[1]
		return 1
	end
	return 0
end

function __fish_wt_using_subcommand
	set -l cmd (__fish_wt_needs_command)
	test -z "$cmd"
	and return 1
	contains -- $cmd[1] $argv
end

complete -c wt -n "__fish_wt_needs_command" -s h -l help -d 'Print help'
complete -c wt -n "__fish_wt_needs_command" -s V -l version -d 'Print version'
complete -c wt -n "__fish_wt_needs_command" -f -a "init" -d 'Generate shell integration code'
complete -c wt -n "__fish_wt_needs_command" -f -a "configure-shell" -d 'Configure shell by writing to config files'
complete -c wt -n "__fish_wt_needs_command" -f -a "config" -d 'Manage configuration'
complete -c wt -n "__fish_wt_needs_command" -f -a "list" -d 'List all worktrees'
complete -c wt -n "__fish_wt_needs_command" -f -a "switch" -d 'Switch to a worktree'
complete -c wt -n "__fish_wt_needs_command" -f -a "remove" -d 'Finish current worktree, returning to primary if current'
complete -c wt -n "__fish_wt_needs_command" -f -a "push" -d 'Push changes between worktrees'
complete -c wt -n "__fish_wt_needs_command" -f -a "merge" -d 'Merge worktree into target branch'
complete -c wt -n "__fish_wt_using_subcommand init" -l cmd -d 'Command prefix (default: wt)' -r
complete -c wt -n "__fish_wt_using_subcommand init" -s h -l help -d 'Print help'
complete -c wt -n "__fish_wt_using_subcommand configure-shell" -l shell -d 'Specific shell to configure (default: all shells with existing config files)' -r -f -a "bash\t''
elvish\t''
fish\t''
nushell\t''
oil\t''
powershell\t''
xonsh\t''
zsh\t''"
complete -c wt -n "__fish_wt_using_subcommand configure-shell" -l cmd -d 'Command prefix (default: wt)' -r
complete -c wt -n "__fish_wt_using_subcommand configure-shell" -s y -l yes -d 'Skip confirmation prompt'
complete -c wt -n "__fish_wt_using_subcommand configure-shell" -s h -l help -d 'Print help'
complete -c wt -n "__fish_wt_using_subcommand config; and not __fish_seen_subcommand_from init list" -s h -l help -d 'Print help'
complete -c wt -n "__fish_wt_using_subcommand config; and not __fish_seen_subcommand_from init list" -f -a "init" -d 'Initialize global configuration file with examples'
complete -c wt -n "__fish_wt_using_subcommand config; and not __fish_seen_subcommand_from init list" -f -a "list" -d 'List all configuration files and their locations'
complete -c wt -n "__fish_wt_using_subcommand config; and __fish_seen_subcommand_from init" -s h -l help -d 'Print help'
complete -c wt -n "__fish_wt_using_subcommand config; and __fish_seen_subcommand_from list" -s h -l help -d 'Print help'
complete -c wt -n "__fish_wt_using_subcommand list" -l format -d 'Output format' -r -f -a "table\t'Human-readable table format'
json\t'JSON format'"
complete -c wt -n "__fish_wt_using_subcommand list" -l branches -d 'Also display branches that don\'t have worktrees'
complete -c wt -n "__fish_wt_using_subcommand list" -s h -l help -d 'Print help (see more with \'--help\')'
complete -c wt -n "__fish_wt_using_subcommand switch" -s b -l base -d 'Base branch to create from (only with --create)' -r
complete -c wt -n "__fish_wt_using_subcommand switch" -s x -l execute -d 'Execute command after switching' -r
complete -c wt -n "__fish_wt_using_subcommand switch" -s c -l create -d 'Create a new branch'
complete -c wt -n "__fish_wt_using_subcommand switch" -s f -l force -d 'Skip confirmation prompt'
complete -c wt -n "__fish_wt_using_subcommand switch" -l no-config-commands -d 'Skip executing post-start commands from project config'
complete -c wt -n "__fish_wt_using_subcommand switch" -s h -l help -d 'Print help'
complete -c wt -n "__fish_wt_using_subcommand remove" -s h -l help -d 'Print help'
complete -c wt -n "__fish_wt_using_subcommand push" -l allow-merge-commits -d 'Allow pushing merge commits (non-linear history)'
complete -c wt -n "__fish_wt_using_subcommand push" -s h -l help -d 'Print help'
complete -c wt -n "__fish_wt_using_subcommand merge" -s m -l message -d 'Custom instruction for commit message generation' -r
complete -c wt -n "__fish_wt_using_subcommand merge" -s s -l squash -d 'Squash all commits into one before merging'
complete -c wt -n "__fish_wt_using_subcommand merge" -s k -l keep -d 'Keep worktree after merging (don\'t remove)'
complete -c wt -n "__fish_wt_using_subcommand merge" -s h -l help -d 'Print help'
complete -c wt -n "__fish_wt_using_subcommand completion" -s h -l help -d 'Print help'
complete -c wt -n "__fish_wt_using_subcommand complete" -s h -l help -d 'Print help'

----- stderr -----
