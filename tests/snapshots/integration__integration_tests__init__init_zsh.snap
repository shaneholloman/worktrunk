---
source: tests/integration_tests/init.rs
info:
  program: wt
  args:
    - init
    - zsh
  env:
    CLICOLOR_FORCE: "1"
    COLUMNS: "150"
    GIT_AUTHOR_DATE: "2025-01-01T00:00:00Z"
    GIT_COMMITTER_DATE: "2025-01-01T00:00:00Z"
    GIT_CONFIG_GLOBAL: /dev/null
    GIT_CONFIG_SYSTEM: /dev/null
    LANG: C
    LC_ALL: C
    SOURCE_DATE_EPOCH: "1761609600"
    WORKTRUNK_CONFIG_PATH: /var/folders/wf/s6ycxvvs4ln8qsdbfx40hnc40000gn/T/.tmpda32N5/test-config.toml
---
success: true
exit_code: 0
----- stdout -----
# worktrunk shell integration for zsh

# Only initialize if wt is available (in PATH or via WORKTRUNK_BIN)
if command -v wt >/dev/null 2>&1 || [[ -n "${WORKTRUNK_BIN:-}" ]]; then
    # Use WORKTRUNK_BIN if set, otherwise default to 'wt'
    # This allows testing development builds: export WORKTRUNK_BIN=./target/debug/wt
    _WORKTRUNK_CMD="${WORKTRUNK_BIN:-wt}"

    # Helper function to parse wt output and handle directives
    # Directives are NUL-terminated to support multi-line commands
    _wt_exec() {
        local exec_cmd="" chunk exit_code
        local exit_code_file stdout_file
        exit_code_file=$(mktemp) || { echo "Failed to create temp file" >&2; return 1; }
        stdout_file=$(mktemp) || { /bin/rm -f "$exit_code_file" 2>/dev/null; echo "Failed to create temp file" >&2; return 1; }

        # Run command and capture output to file to avoid process substitution issues
        # Process substitution in zsh can hang in non-interactive mode
        # Let stderr pass through to terminal (preserves TTY for color detection)
        command "$_WORKTRUNK_CMD" "$@" > "$stdout_file"
        echo "$?" > "$exit_code_file"

        # Parse stdout for directives (NUL-delimited)
        # The || [[ -n "$chunk" ]] handles non-NUL-terminated output (e.g., error messages)
        while IFS= read -r -d '' chunk || [[ -n "$chunk" ]]; do
            if [[ "$chunk" == __WORKTRUNK_CD__* ]]; then
                # CD directive - extract path and change directory
                local path="${chunk#__WORKTRUNK_CD__}"
                \cd "$path"
            elif [[ "$chunk" == __WORKTRUNK_EXEC__* ]]; then
                # EXEC directive - extract command (may contain newlines)
                exec_cmd="${chunk#__WORKTRUNK_EXEC__}"
            else
                # Regular output - print it with newline
                printf '%s\n' "$chunk"
            fi
        done < "$stdout_file"

        # Read exit code from temp file
        exit_code=$(cat "$exit_code_file" 2>/dev/null || echo 0)

        # Cleanup temp files (use absolute path for --no-rcs compatibility)
        /bin/rm -f "$exit_code_file" "$stdout_file" 2>/dev/null || true

        # Execute command if one was specified
        # Security: Command is user-provided from -x flag; eval is intentional.
        # NUL-termination allows multi-line commands.
        # Exit code semantics: Returns wt's exit code, not the executed command's.
        # This allows detecting wt failures (e.g., branch creation errors).
        # The executed command runs for side effects; its failure is logged but doesn't affect exit code.
        if [[ -n "$exec_cmd" ]]; then
            if ! eval "$exec_cmd"; then
                echo "Warning: Command execution failed (exit code $?)" >&2
            fi
        fi

        return $exit_code
    }

    # Override wt command to add --internal flag
    wt() {
        local use_source=false
        local -a args
        local saved_cmd="$_WORKTRUNK_CMD"

        # Check for --source flag and strip it
        for arg in "$@"; do
            if [[ "$arg" == "--source" ]]; then
                use_source=true
            else
                args+=("$arg")
            fi
        done

        # If --source was specified, build and use local debug binary
        if [[ "$use_source" == true ]]; then
            if ! cargo build --quiet; then
                _WORKTRUNK_CMD="$saved_cmd"
                return 1
            fi
            _WORKTRUNK_CMD="./target/debug/wt"
        fi

        # Force colors if wrapper's stdout is a TTY (respects NO_COLOR and explicit CLICOLOR_FORCE)
        if [[ -z "${NO_COLOR:-}" && -z "${CLICOLOR_FORCE:-}" ]]; then
            if [[ -t 1 ]]; then export CLICOLOR_FORCE=1; fi
        fi

        # Always use --internal mode for directive support
        _wt_exec --internal "${args[@]}"

        # Restore original command
        local result=$?
        _WORKTRUNK_CMD="$saved_cmd"
        return $result
    }

    # Dynamic completion function for zsh
    _wt_complete() {
        local -a completions
        local -a words

        # Get current command line as array
        words=("${(@)words}")

        # Call wt complete with current command line
        completions=(${(f)"$(command "$_WORKTRUNK_CMD" complete "${words[@]}" 2>/dev/null)"})

        # Add completions
        compadd -a completions
    }

    # Register dynamic completion (only if compdef is available)
    # In non-interactive shells or test environments, the completion system may not be loaded
    if (( $+functions[compdef] )); then
        compdef _wt_complete wt
    fi
fi

# Static completions (commands and flags)
#compdef wt

autoload -U is-at-least

_wt() {
    typeset -A opt_args
    typeset -a _arguments_options
    local ret=1

    if is-at-least 5.2; then
        _arguments_options=(-s -S -C)
    else
        _arguments_options=(-s -C)
    fi

    local context curcontext="$curcontext" state line
    _arguments "${_arguments_options[@]}" : \
'-v[Enable verbose output (show git commands and debug info)]' \
'--verbose[Enable verbose output (show git commands and debug info)]' \
'-h[Print help]' \
'--help[Print help]' \
'-V[Print version]' \
'--version[Print version]' \
":: :_wt_commands" \
"*::: :->wt" \
&& ret=0
    case $state in
    (wt)
        words=($line[1] "${words[@]}")
        (( CURRENT += 1 ))
        curcontext="${curcontext%:*:*}:wt-command-$line[1]:"
        case $line[1] in
            (init)
_arguments "${_arguments_options[@]}" : \
'-v[Enable verbose output (show git commands and debug info)]' \
'--verbose[Enable verbose output (show git commands and debug info)]' \
'-h[Print help]' \
'--help[Print help]' \
':shell -- Shell to generate code for:(bash elvish fish nushell oil powershell xonsh zsh)' \
&& ret=0
;;
(config)
_arguments "${_arguments_options[@]}" : \
'-v[Enable verbose output (show git commands and debug info)]' \
'--verbose[Enable verbose output (show git commands and debug info)]' \
'-h[Print help]' \
'--help[Print help]' \
":: :_wt__config_commands" \
"*::: :->config" \
&& ret=0

    case $state in
    (config)
        words=($line[1] "${words[@]}")
        (( CURRENT += 1 ))
        curcontext="${curcontext%:*:*}:wt-config-command-$line[1]:"
        case $line[1] in
            (init)
_arguments "${_arguments_options[@]}" : \
'-v[Enable verbose output (show git commands and debug info)]' \
'--verbose[Enable verbose output (show git commands and debug info)]' \
'-h[Print help]' \
'--help[Print help]' \
&& ret=0
;;
(list)
_arguments "${_arguments_options[@]}" : \
'-v[Enable verbose output (show git commands and debug info)]' \
'--verbose[Enable verbose output (show git commands and debug info)]' \
'-h[Print help]' \
'--help[Print help]' \
&& ret=0
;;
(help)
_arguments "${_arguments_options[@]}" : \
'-v[Enable verbose output (show git commands and debug info)]' \
'--verbose[Enable verbose output (show git commands and debug info)]' \
'-h[Print help]' \
'--help[Print help]' \
&& ret=0
;;
(refresh-cache)
_arguments "${_arguments_options[@]}" : \
'-v[Enable verbose output (show git commands and debug info)]' \
'--verbose[Enable verbose output (show git commands and debug info)]' \
'-h[Print help]' \
'--help[Print help]' \
&& ret=0
;;
(shell)
_arguments "${_arguments_options[@]}" : \
'--shell=[Specific shell to configure (default\: all shells with existing config files)]:SHELL:(bash elvish fish nushell oil powershell xonsh zsh)' \
'-f[Skip confirmation prompt]' \
'--force[Skip confirmation prompt]' \
'-v[Enable verbose output (show git commands and debug info)]' \
'--verbose[Enable verbose output (show git commands and debug info)]' \
'-h[Print help]' \
'--help[Print help]' \
&& ret=0
;;
        esac
    ;;
esac
;;
(beta)
_arguments "${_arguments_options[@]}" : \
'-v[Enable verbose output (show git commands and debug info)]' \
'--verbose[Enable verbose output (show git commands and debug info)]' \
'-h[Print help]' \
'--help[Print help]' \
":: :_wt__beta_commands" \
"*::: :->beta" \
&& ret=0

    case $state in
    (beta)
        words=($line[1] "${words[@]}")
        (( CURRENT += 1 ))
        curcontext="${curcontext%:*:*}:wt-beta-command-$line[1]:"
        case $line[1] in
            (run-hook)
_arguments "${_arguments_options[@]}" : \
'-f[Skip command approval prompts]' \
'--force[Skip command approval prompts]' \
'-v[Enable verbose output (show git commands and debug info)]' \
'--verbose[Enable verbose output (show git commands and debug info)]' \
'-h[Print help]' \
'--help[Print help]' \
':hook_type -- Hook type to run:(post-create post-start pre-commit pre-merge post-merge)' \
&& ret=0
;;
(commit)
_arguments "${_arguments_options[@]}" : \
'-f[Skip command approval prompts]' \
'--force[Skip command approval prompts]' \
'--no-verify[Skip all project hooks (pre-commit-command)]' \
'-v[Enable verbose output (show git commands and debug info)]' \
'--verbose[Enable verbose output (show git commands and debug info)]' \
'-h[Print help]' \
'--help[Print help]' \
&& ret=0
;;
(squash)
_arguments "${_arguments_options[@]}" : \
'-f[Skip command approval prompts]' \
'--force[Skip command approval prompts]' \
'--no-verify[Skip all project hooks (pre-commit-command, pre-merge-command)]' \
'-v[Enable verbose output (show git commands and debug info)]' \
'--verbose[Enable verbose output (show git commands and debug info)]' \
'-h[Print help]' \
'--help[Print help]' \
'::target -- Target branch to squash against (defaults to default branch):_default' \
&& ret=0
;;
(push)
_arguments "${_arguments_options[@]}" : \
'--allow-merge-commits[Allow pushing merge commits (non-linear history)]' \
'-v[Enable verbose output (show git commands and debug info)]' \
'--verbose[Enable verbose output (show git commands and debug info)]' \
'-h[Print help (see more with '\''--help'\'')]' \
'--help[Print help (see more with '\''--help'\'')]' \
'::target -- Target branch (defaults to default branch):_default' \
&& ret=0
;;
(rebase)
_arguments "${_arguments_options[@]}" : \
'-v[Enable verbose output (show git commands and debug info)]' \
'--verbose[Enable verbose output (show git commands and debug info)]' \
'-h[Print help]' \
'--help[Print help]' \
'::target -- Target branch to rebase onto (defaults to default branch):_default' \
&& ret=0
;;
(ask-approvals)
_arguments "${_arguments_options[@]}" : \
'-f[Skip command approval prompts]' \
'--force[Skip command approval prompts]' \
'--all[Show all commands including already-approved ones]' \
'-v[Enable verbose output (show git commands and debug info)]' \
'--verbose[Enable verbose output (show git commands and debug info)]' \
'-h[Print help]' \
'--help[Print help]' \
&& ret=0
;;
(select)
_arguments "${_arguments_options[@]}" : \
'-v[Enable verbose output (show git commands and debug info)]' \
'--verbose[Enable verbose output (show git commands and debug info)]' \
'-h[Print help (see more with '\''--help'\'')]' \
'--help[Print help (see more with '\''--help'\'')]' \
&& ret=0
;;
        esac
    ;;
esac
;;
(list)
_arguments "${_arguments_options[@]}" : \
'--format=[Output format]:FORMAT:((table\:"Human-readable table format"
json\:"Machine-readable JSON with display fields (includes styled unicode for rendering)"))' \
'--branches[Include branches without worktrees]' \
'--full[Show CI status, conflict detection, and complete diff statistics]' \
'-v[Enable verbose output (show git commands and debug info)]' \
'--verbose[Enable verbose output (show git commands and debug info)]' \
'-h[Print help (see more with '\''--help'\'')]' \
'--help[Print help (see more with '\''--help'\'')]' \
&& ret=0
;;
(switch)
_arguments "${_arguments_options[@]}" : \
'-b+[Base branch to create from (only with --create). Use '\''@'\'' for current HEAD]:BASE:_default' \
'--base=[Base branch to create from (only with --create). Use '\''@'\'' for current HEAD]:BASE:_default' \
'-x+[Execute command after switching]:EXECUTE:_default' \
'--execute=[Execute command after switching]:EXECUTE:_default' \
'-c[Create a new branch]' \
'--create[Create a new branch]' \
'-f[Skip confirmation prompt]' \
'--force[Skip confirmation prompt]' \
'--no-verify[Skip all project hooks (post-create, post-start)]' \
'-v[Enable verbose output (show git commands and debug info)]' \
'--verbose[Enable verbose output (show git commands and debug info)]' \
'-h[Print help]' \
'--help[Print help]' \
':branch -- Branch name, worktree path, '\''@'\'' for current HEAD, or '\''-'\'' for previous branch:_default' \
&& ret=0
;;
(remove)
_arguments "${_arguments_options[@]}" : \
'--no-delete-branch[Don'\''t delete the branch after removing the worktree (by default, branches are deleted)]' \
'-v[Enable verbose output (show git commands and debug info)]' \
'--verbose[Enable verbose output (show git commands and debug info)]' \
'-h[Print help]' \
'--help[Print help]' \
'*::worktrees -- Worktree names or branches to remove (use '\''@'\'' for current, defaults to current if none specified):_default' \
&& ret=0
;;
(merge)
_arguments "${_arguments_options[@]}" : \
'--no-squash[Disable squashing commits (by default, commits are squashed into one before merging)]' \
'--no-commit[Push commits as-is without transformations (requires clean tree; implies --no-squash, --no-remove, and skips rebase)]' \
'--no-remove[Keep worktree after merging (don'\''t remove)]' \
'--no-verify[Skip all project hooks (pre-merge-command)]' \
'-f[Skip approval prompts for commands]' \
'--force[Skip approval prompts for commands]' \
'--tracked-only[Only stage tracked files (git add -u) instead of all files (git add -A)]' \
'-v[Enable verbose output (show git commands and debug info)]' \
'--verbose[Enable verbose output (show git commands and debug info)]' \
'-h[Print help (see more with '\''--help'\'')]' \
'--help[Print help (see more with '\''--help'\'')]' \
'::target -- Target branch to merge into (defaults to default branch):_default' \
&& ret=0
;;
(completion)
_arguments "${_arguments_options[@]}" : \
'-v[Enable verbose output (show git commands and debug info)]' \
'--verbose[Enable verbose output (show git commands and debug info)]' \
'-h[Print help]' \
'--help[Print help]' \
':shell -- Shell to generate completions for:(bash elvish fish nushell oil powershell xonsh zsh)' \
&& ret=0
;;
(complete)
_arguments "${_arguments_options[@]}" : \
'-v[Enable verbose output (show git commands and debug info)]' \
'--verbose[Enable verbose output (show git commands and debug info)]' \
'-h[Print help]' \
'--help[Print help]' \
'*::args -- Arguments to complete:_default' \
&& ret=0
;;
        esac
    ;;
esac
}

(( $+functions[_wt_commands] )) ||
_wt_commands() {
    local commands; commands=(
'init:Generate shell integration code' \
'config:Manage configuration' \
'beta:Development and testing utilities' \
'list:List worktrees and optionally branches' \
'switch:Switch to a worktree' \
'remove:Finish current worktree, returning to primary if current' \
'merge:Merge worktree into target branch' \
'completion:Generate shell completion script (deprecated - use init instead)' \
'complete:Internal completion helper (hidden)' \
    )
    _describe -t commands 'wt commands' commands "$@"
}
(( $+functions[_wt__beta_commands] )) ||
_wt__beta_commands() {
    local commands; commands=(
'run-hook:Run a project hook for testing' \
'commit:Commit changes with LLM-generated message' \
'squash:Squash commits with LLM-generated message' \
'push:Push changes to target branch' \
'rebase:Rebase current branch onto target branch' \
'ask-approvals:Approve commands in the project config (shows unapproved by default)' \
'select:Interactive worktree selector' \
    )
    _describe -t commands 'wt beta commands' commands "$@"
}
(( $+functions[_wt__beta__ask-approvals_commands] )) ||
_wt__beta__ask-approvals_commands() {
    local commands; commands=()
    _describe -t commands 'wt beta ask-approvals commands' commands "$@"
}
(( $+functions[_wt__beta__commit_commands] )) ||
_wt__beta__commit_commands() {
    local commands; commands=()
    _describe -t commands 'wt beta commit commands' commands "$@"
}
(( $+functions[_wt__beta__push_commands] )) ||
_wt__beta__push_commands() {
    local commands; commands=()
    _describe -t commands 'wt beta push commands' commands "$@"
}
(( $+functions[_wt__beta__rebase_commands] )) ||
_wt__beta__rebase_commands() {
    local commands; commands=()
    _describe -t commands 'wt beta rebase commands' commands "$@"
}
(( $+functions[_wt__beta__run-hook_commands] )) ||
_wt__beta__run-hook_commands() {
    local commands; commands=()
    _describe -t commands 'wt beta run-hook commands' commands "$@"
}
(( $+functions[_wt__beta__select_commands] )) ||
_wt__beta__select_commands() {
    local commands; commands=()
    _describe -t commands 'wt beta select commands' commands "$@"
}
(( $+functions[_wt__beta__squash_commands] )) ||
_wt__beta__squash_commands() {
    local commands; commands=()
    _describe -t commands 'wt beta squash commands' commands "$@"
}
(( $+functions[_wt__complete_commands] )) ||
_wt__complete_commands() {
    local commands; commands=()
    _describe -t commands 'wt complete commands' commands "$@"
}
(( $+functions[_wt__completion_commands] )) ||
_wt__completion_commands() {
    local commands; commands=()
    _describe -t commands 'wt completion commands' commands "$@"
}
(( $+functions[_wt__config_commands] )) ||
_wt__config_commands() {
    local commands; commands=(
'init:Initialize global configuration file with examples' \
'list:List all configuration files and their locations' \
'help:Show setup guide for AI-generated commit messages' \
'refresh-cache:Refresh the cached default branch by querying the remote' \
'shell:Configure shell by writing to config files' \
    )
    _describe -t commands 'wt config commands' commands "$@"
}
(( $+functions[_wt__config__help_commands] )) ||
_wt__config__help_commands() {
    local commands; commands=()
    _describe -t commands 'wt config help commands' commands "$@"
}
(( $+functions[_wt__config__init_commands] )) ||
_wt__config__init_commands() {
    local commands; commands=()
    _describe -t commands 'wt config init commands' commands "$@"
}
(( $+functions[_wt__config__list_commands] )) ||
_wt__config__list_commands() {
    local commands; commands=()
    _describe -t commands 'wt config list commands' commands "$@"
}
(( $+functions[_wt__config__refresh-cache_commands] )) ||
_wt__config__refresh-cache_commands() {
    local commands; commands=()
    _describe -t commands 'wt config refresh-cache commands' commands "$@"
}
(( $+functions[_wt__config__shell_commands] )) ||
_wt__config__shell_commands() {
    local commands; commands=()
    _describe -t commands 'wt config shell commands' commands "$@"
}
(( $+functions[_wt__init_commands] )) ||
_wt__init_commands() {
    local commands; commands=()
    _describe -t commands 'wt init commands' commands "$@"
}
(( $+functions[_wt__list_commands] )) ||
_wt__list_commands() {
    local commands; commands=()
    _describe -t commands 'wt list commands' commands "$@"
}
(( $+functions[_wt__merge_commands] )) ||
_wt__merge_commands() {
    local commands; commands=()
    _describe -t commands 'wt merge commands' commands "$@"
}
(( $+functions[_wt__remove_commands] )) ||
_wt__remove_commands() {
    local commands; commands=()
    _describe -t commands 'wt remove commands' commands "$@"
}
(( $+functions[_wt__switch_commands] )) ||
_wt__switch_commands() {
    local commands; commands=()
    _describe -t commands 'wt switch commands' commands "$@"
}

if [ "$funcstack[1]" = "_wt" ]; then
    _wt "$@"
else
    compdef _wt wt
fi

----- stderr -----
