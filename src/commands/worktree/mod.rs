//! Worktree operations with file-based shell integration.
//!
//! # The Directory Change Problem
//!
//! Worktree commands (`switch`, `remove`, `merge`) need to change the user's working directory,
//! but there's a fundamental Unix limitation: **child processes cannot change their parent's
//! working directory**. This is a security feature and core Unix design principle.
//!
//! When a user runs `wt switch my-feature`, the `wt` binary runs as a child process of the shell.
//! The binary can change *its own* working directory, but when it exits, the parent shell remains
//! in the original directory.
//!
//! # Solution: File-Based Directive Passing
//!
//! Shell wrappers create a temp file and set `WORKTRUNK_DIRECTIVE_FILE` to its path:
//!
//! 1. Shell wrapper creates temp file via `mktemp`
//! 2. Shell wrapper sets `WORKTRUNK_DIRECTIVE_FILE=/path/to/temp`
//! 3. wt binary writes commands like `cd '/path'` to that file
//! 4. Shell wrapper sources the file after wt exits
//!
//! ## Without Shell Integration (Direct Binary Call)
//!
//! ```bash
//! $ wt switch my-feature
//! Created new branch and worktree for 'my-feature' @ /path/to/worktree
//!
//! Run `wt config shell install` to enable automatic cd
//!
//! $ pwd
//! /original/directory  # ← User is still here!
//! ```
//!
//! The binary performs git operations and prints user-friendly messages, but **cannot** change
//! the parent shell's directory. User must manually `cd` to the worktree.
//!
//! ## With Shell Integration
//!
//! ```bash
//! $ wt switch my-feature
//! Created new branch and worktree for 'my-feature' @ /path/to/worktree
//!
//! $ pwd
//! /path/to/worktree  # ← Automatically changed!
//! ```
//!
//! When shell integration is enabled (`eval "$(wt config shell init bash)"`), the shell wrapper:
//!
//! 1. Creates a temp file and sets `WORKTRUNK_DIRECTIVE_FILE` to its path
//! 2. Runs the wt binary (which writes `cd '/path'` to the temp file)
//! 3. Sources the temp file after wt exits
//!
//! # Implementation Details
//!
//! Result types (`SwitchResult`, `RemoveResult`) are pure data structures that only contain
//! operation results. All presentation logic is handled by the `output` module:
//!
//! - `output::handle_switch_output()`: Formats and outputs switch operation results
//! - `output::handle_remove_output()`: Formats and outputs remove operation results
//!
//! The output handlers check `is_shell_integration_active()` to determine if hints should
//! be suppressed (when shell integration is already configured).
//!
//! ## Exit Code Semantics
//!
//! When using `-x` to execute commands after switching:
//!
//! - **If wt operation fails**: Returns wt's exit code (command never executes)
//! - **If wt succeeds but command fails**: Returns the command's exit code
//! - **Rationale**: Enables command chaining with proper error propagation
//!
//! Example:
//! ```bash
//! wt switch feature -x "cargo build" && cargo test
//! # If wt fails (e.g., worktree doesn't exist), cargo build never runs
//! # If cargo build fails, cargo test doesn't run (exit code propagates)
//! ```
//!
//! The shell wrapper is generated by `wt config shell init <shell>` from templates in `templates/`.

mod hooks;
mod push;
mod remove;
mod resolve;
mod switch;
mod types;

// Re-export public types and functions
pub use push::handle_push;
pub use remove::{handle_remove, handle_remove_current};
pub(crate) use resolve::paths_match;
pub use resolve::{
    compute_worktree_path, get_path_mismatch, is_worktree_at_expected_path, resolve_worktree_arg,
    worktree_display_name,
};
pub use switch::{execute_switch, plan_switch};
pub use types::{
    BranchDeletionMode, MergeOperations, OperationMode, RemoveResult, SwitchBranchInfo, SwitchPlan,
    SwitchResult,
};
