//! Worktree operations with file-based shell integration.
//!
//! # The Directory Change Problem
//!
//! Worktree commands (`switch`, `remove`, `merge`) need to change the user's working directory,
//! but there's a fundamental Unix limitation: **child processes cannot change their parent's
//! working directory**. This is a security feature and core Unix design principle.
//!
//! When a user runs `wt switch my-feature`, the `wt` binary runs as a child process of the shell.
//! The binary can change *its own* working directory, but when it exits, the parent shell remains
//! in the original directory.
//!
//! # Solution: File-Based Directive Passing
//!
//! Shell wrappers create a temp file and set `WORKTRUNK_DIRECTIVE_FILE` to its path:
//!
//! 1. Shell wrapper creates temp file via `mktemp`
//! 2. Shell wrapper sets `WORKTRUNK_DIRECTIVE_FILE=/path/to/temp`
//! 3. wt binary writes commands like `cd '/path'` to that file
//! 4. Shell wrapper sources the file after wt exits
//!
//! ## Without Shell Integration (Direct Binary Call)
//!
//! ```bash
//! $ wt switch my-feature
//! Created new branch and worktree for 'my-feature' @ /path/to/worktree
//!
//! Run `wt config shell install` to enable automatic cd
//!
//! $ pwd
//! /original/directory  # ← User is still here!
//! ```
//!
//! The binary performs git operations and prints user-friendly messages, but **cannot** change
//! the parent shell's directory. User must manually `cd` to the worktree.
//!
//! ## With Shell Integration
//!
//! ```bash
//! $ wt switch my-feature
//! Created new branch and worktree for 'my-feature' @ /path/to/worktree
//!
//! $ pwd
//! /path/to/worktree  # ← Automatically changed!
//! ```
//!
//! When shell integration is enabled (`eval "$(wt config shell init bash)"`), the shell wrapper:
//!
//! 1. Creates a temp file and sets `WORKTRUNK_DIRECTIVE_FILE` to its path
//! 2. Runs the wt binary (which writes `cd '/path'` to the temp file)
//! 3. Sources the temp file after wt exits
//!
//! # Implementation Details
//!
//! Result types (`SwitchResult`, `RemoveResult`) are pure data structures that only contain
//! operation results. All presentation logic is handled by the `output` module:
//!
//! - `output::handle_switch_output()`: Formats and outputs switch operation results
//! - `output::handle_remove_output()`: Formats and outputs remove operation results
//!
//! The output handlers check `is_shell_integration_active()` to determine if hints should
//! be suppressed (when shell integration is already configured).
//!
//! ## Exit Code Semantics
//!
//! When using `-x` to execute commands after switching:
//!
//! - **If wt operation fails**: Returns wt's exit code (command never executes)
//! - **If wt succeeds but command fails**: Returns the command's exit code
//! - **Rationale**: Enables command chaining with proper error propagation
//!
//! Example:
//! ```bash
//! wt switch feature -x "cargo build" && cargo test
//! # If wt fails (e.g., worktree doesn't exist), cargo build never runs
//! # If cargo build fails, cargo test doesn't run (exit code propagates)
//! ```
//!
//! The shell wrapper is generated by `wt config shell init <shell>` from templates in `templates/`.

use anyhow::Context;
use color_print::cformat;
use dunce::canonicalize;
use normalize_path::NormalizePath;
use std::path::PathBuf;
use worktrunk::HookType;
use worktrunk::config::WorktrunkConfig;
use worktrunk::git::{GitError, Repository, ResolvedWorktree};
use worktrunk::styling::{
    format_with_gutter, hint_message, info_message, progress_message, success_message,
    suggest_command, warning_message,
};

use super::command_executor::CommandContext;
use super::hooks::{HookFailureStrategy, prepare_hook_commands, spawn_hook_commands_background};
use super::repository_ext::{RemoveTarget, RepositoryCliExt};

/// Generate a backup path for the given path with a timestamp suffix.
///
/// For paths with extensions: `file.txt` → `file.txt.bak.TIMESTAMP`
/// For paths without extensions: `foo` → `foo.bak.TIMESTAMP`
fn generate_backup_path(path: &std::path::Path, suffix: &str) -> PathBuf {
    if path.extension().is_none() {
        // Path has no extension (e.g., /repo/feature)
        path.with_file_name(format!(
            "{}.bak.{suffix}",
            path.file_name().unwrap().to_string_lossy()
        ))
    } else {
        // Path has an extension (e.g., /repo.feature or /file.txt)
        path.with_extension(format!(
            "{}.bak.{suffix}",
            path.extension()
                .map(|e| e.to_string_lossy().to_string())
                .unwrap_or_default()
        ))
    }
}

/// Context for worktree resolution - determines which checks are performed.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ResolutionContext {
    /// Creating or switching to a worktree - path occupation is an error
    /// because we need to create a worktree at the expected path.
    CreateOrSwitch,
    /// Removing a worktree - we only care if the branch has a worktree,
    /// path occupation is irrelevant since we're not creating anything.
    Remove,
}

/// Resolve a worktree argument using branch-first lookup.
///
/// Resolution order:
/// 1. Special symbols ("@", "-", "^") are handled specially
/// 2. Resolve argument as branch name
/// 3. If branch has a worktree, return it
/// 4. Otherwise, return branch-only (no worktree)
///
/// For `CreateOrSwitch` context: If the branch has no worktree but expected
/// path is occupied by another branch's worktree, an error is raised.
///
/// For `Remove` context: Path occupation is ignored since we're not creating
/// a worktree - we just return `BranchOnly` if no worktree exists.
pub fn resolve_worktree_arg(
    repo: &Repository,
    name: &str,
    config: &WorktrunkConfig,
    context: ResolutionContext,
) -> anyhow::Result<ResolvedWorktree> {
    // Special symbols
    match name {
        "@" => {
            // Current worktree by path - works even in detached HEAD
            let path = repo.worktree_root()?.to_path_buf();
            let worktrees = repo.list_worktrees()?;
            let branch = worktrees
                .iter()
                .find(|wt| wt.path == path)
                .and_then(|wt| wt.branch.clone());
            return Ok(ResolvedWorktree::Worktree { path, branch });
        }
        "-" | "^" => {
            // These resolve to branch names, use standard branch-based lookup
            return repo.resolve_worktree(name);
        }
        _ => {}
    }

    // Resolve as branch name
    let branch = repo.resolve_worktree_name(name)?;

    // Branch-first: check if branch has worktree anywhere
    if let Some(path) = repo.worktree_for_branch(&branch)? {
        return Ok(ResolvedWorktree::Worktree {
            path,
            branch: Some(branch),
        });
    }

    // No worktree for branch - check if expected path is occupied (only for create/switch)
    if context == ResolutionContext::CreateOrSwitch {
        let expected_path = compute_worktree_path(repo, name, config)?;
        if let Some((_, occupant_branch)) = repo.worktree_at_path(&expected_path)? {
            // Path is occupied by a different branch's worktree
            return Err(GitError::WorktreePathOccupied {
                branch,
                path: expected_path,
                occupant: occupant_branch,
            }
            .into());
        }
    }

    // No worktree for branch (and path not occupied, or we don't care about path)
    Ok(ResolvedWorktree::BranchOnly { branch })
}

/// Compute the expected worktree path for a branch name.
///
/// For the default branch, returns the repo root (main worktree location).
/// For other branches, applies the `worktree-path` template from config.
pub fn compute_worktree_path(
    repo: &Repository,
    branch: &str,
    config: &WorktrunkConfig,
) -> anyhow::Result<PathBuf> {
    let default_branch = repo.default_branch().unwrap_or_default();
    let is_bare = repo.is_bare()?;
    compute_worktree_path_with(repo, branch, config, &default_branch, is_bare)
}

/// Check if a worktree is at its expected path based on config template.
///
/// Returns true if the worktree's actual path matches what `compute_worktree_path`
/// would generate for its branch. Detached HEAD always returns false (no expected path).
///
/// Uses canonicalization to handle symlinks and relative paths correctly.
///
/// Note: For hot paths where default_branch and is_bare are already known,
/// use `is_worktree_at_expected_path_with` to avoid redundant git calls.
fn is_worktree_at_expected_path(
    wt: &worktrunk::git::Worktree,
    repo: &Repository,
    config: &WorktrunkConfig,
) -> bool {
    // Compute default_branch and is_bare once, then delegate to the optimized variant
    let default_branch = repo.default_branch().unwrap_or_default();
    let is_bare = repo.is_bare().unwrap_or(false);
    is_worktree_at_expected_path_with(wt, repo, config, &default_branch, is_bare)
}

/// Check if a worktree is at its expected path, with pre-computed values.
///
/// Use this when `default_branch` and `is_bare` are already known (e.g., in list command)
/// to avoid redundant git calls.
pub fn is_worktree_at_expected_path_with(
    wt: &worktrunk::git::Worktree,
    repo: &Repository,
    config: &WorktrunkConfig,
    default_branch: &str,
    is_bare: bool,
) -> bool {
    use dunce::canonicalize;

    match &wt.branch {
        Some(branch) => compute_worktree_path_with(repo, branch, config, default_branch, is_bare)
            .map(
                |expected| match (canonicalize(&wt.path), canonicalize(&expected)) {
                    (Ok(actual), Ok(expected)) => actual == expected,
                    _ => wt.path == expected,
                },
            )
            .unwrap_or(false),
        None => false,
    }
}

/// Optimized variant of `compute_worktree_path` that accepts pre-computed values.
///
/// Use this when `default_branch` and `is_bare` are already known to avoid
/// redundant git calls.
fn compute_worktree_path_with(
    repo: &Repository,
    branch: &str,
    config: &WorktrunkConfig,
    default_branch: &str,
    is_bare: bool,
) -> anyhow::Result<PathBuf> {
    let repo_root = repo.worktree_base()?;

    // Default branch lives at repo root (main worktree), not a templated path.
    // Exception: bare repos have no main worktree, so all branches use templated paths.
    if !is_bare && branch == default_branch {
        return Ok(repo_root);
    }

    let repo_name = repo_root
        .file_name()
        .ok_or_else(|| anyhow::anyhow!("Repository path has no filename: {}", repo_root.display()))?
        .to_str()
        .ok_or_else(|| {
            anyhow::anyhow!(
                "Repository path contains invalid UTF-8: {}",
                repo_root.display()
            )
        })?;

    let relative_path = config
        .format_path(repo_name, branch)
        .map_err(|e| anyhow::anyhow!("Failed to format worktree path: {e}"))?;

    Ok(repo_root.join(relative_path).normalize())
}

/// Compute a user-facing display name for a worktree.
///
/// Returns styled content with branch names bolded:
/// - If branch is consistent with worktree location: just the branch name (bolded)
/// - If branch differs from expected location: `dir_name (on **branch**)` (both bolded)
/// - If detached HEAD: `dir_name (detached)` (dir_name bolded)
///
/// "Consistent" means the worktree path matches `compute_worktree_path(branch)`,
/// which returns repo root for default branch and templated path for others.
pub fn worktree_display_name(
    wt: &worktrunk::git::Worktree,
    repo: &Repository,
    config: &WorktrunkConfig,
) -> String {
    let dir_name = wt.dir_name();

    match &wt.branch {
        Some(branch) => {
            if is_worktree_at_expected_path(wt, repo, config) {
                cformat!("<bold>{branch}</>")
            } else {
                cformat!("<bold>{dir_name}</> (on <bold>{branch}</>)")
            }
        }
        None => cformat!("<bold>{dir_name}</> (detached)"),
    }
}

/// Flags indicating which merge operations occurred
#[derive(Debug, Clone, Copy)]
pub struct MergeOperations {
    pub committed: bool,
    pub squashed: bool,
    pub rebased: bool,
}

/// Result of a worktree switch operation
pub enum SwitchResult {
    /// Already at the target worktree (no action taken)
    AlreadyAt(PathBuf),
    /// Switched to existing worktree at the given path
    Existing(PathBuf),
    /// Created new worktree at the given path
    Created {
        path: PathBuf,
        /// True if we used `-b` to create a new branch (--create flag)
        created_branch: bool,
        /// Base branch when creating new branch (e.g., "main")
        base_branch: Option<String>,
        /// Remote tracking branch if created from remote (e.g., "origin/feature")
        /// This is set when git's DWIM created a local branch from a remote
        from_remote: Option<String>,
    },
}

impl SwitchResult {
    /// Get the worktree path
    pub fn path(&self) -> &PathBuf {
        match self {
            SwitchResult::AlreadyAt(path) => path,
            SwitchResult::Existing(path) => path,
            SwitchResult::Created { path, .. } => path,
        }
    }
}

/// Branch state for a switch operation.
#[derive(Debug, Clone)]
pub struct SwitchBranchInfo {
    /// The branch being switched to
    pub branch: String,
    /// Expected path when there's a path mismatch (None = path matches template)
    pub expected_path: Option<PathBuf>,
}

impl SwitchBranchInfo {
    /// The branch name
    pub fn branch(&self) -> &str {
        &self.branch
    }
}

/// How the branch should be handled after worktree removal.
///
/// This enum replaces the previous `no_delete_branch: bool, force_delete: bool` pattern,
/// making the three valid states explicit and preventing invalid combinations.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum BranchDeletionMode {
    /// Keep the branch regardless of merge status (--no-delete-branch flag).
    Keep,
    /// Delete the branch only if it's fully merged into the target branch (default).
    SafeDelete,
    /// Delete the branch even if it's not merged (-D flag).
    ForceDelete,
}

impl BranchDeletionMode {
    /// Create from CLI flags.
    ///
    /// `--no-delete-branch` takes precedence over `-D` (force delete).
    pub fn from_flags(no_delete_branch: bool, force_delete: bool) -> Self {
        if no_delete_branch {
            Self::Keep
        } else if force_delete {
            Self::ForceDelete
        } else {
            Self::SafeDelete
        }
    }

    /// Whether the branch should be kept (not deleted).
    pub fn should_keep(&self) -> bool {
        matches!(self, Self::Keep)
    }

    /// Whether to force delete even if not merged.
    pub fn is_force(&self) -> bool {
        matches!(self, Self::ForceDelete)
    }
}

/// Result of a worktree remove operation
pub enum RemoveResult {
    /// Removed worktree and returned to main (if needed)
    RemovedWorktree {
        main_path: PathBuf,
        worktree_path: PathBuf,
        changed_directory: bool,
        /// Branch name, if known. None for detached HEAD state.
        branch_name: Option<String>,
        deletion_mode: BranchDeletionMode,
        target_branch: Option<String>,
        /// Pre-computed integration reason (if branch is integrated with target).
        /// Computed upfront to avoid race conditions when removing multiple worktrees
        /// in background mode (background git operations can hold locks that cause
        /// subsequent integration checks to fail).
        integration_reason: Option<worktrunk::git::IntegrationReason>,
        /// Force git worktree removal even with untracked files.
        force_worktree: bool,
    },
    /// Branch exists but has no worktree - attempt branch deletion only
    BranchOnly {
        branch_name: String,
        deletion_mode: BranchDeletionMode,
    },
}

pub fn handle_switch(
    branch: &str,
    create: bool,
    base: Option<&str>,
    force: bool,
    clobber: bool,
    no_verify: bool,
    config: &WorktrunkConfig,
) -> anyhow::Result<(SwitchResult, SwitchBranchInfo)> {
    let repo = Repository::current();

    // Get the actual current branch BEFORE switching.
    // This is what we'll record as "previous" in history for `wt switch -` support.
    let actual_current_branch = repo.current_branch().ok().flatten();

    // Resolve special branch names ("@" for current, "-" for previous)
    let resolved_branch = repo
        .resolve_worktree_name(branch)
        .context("Failed to resolve branch name")?;

    // Record actual current branch as new "previous" for ping-pong behavior
    let new_previous = actual_current_branch;

    // Resolve base if provided
    let resolved_base = if let Some(base_str) = base {
        Some(repo.resolve_worktree_name(base_str)?)
    } else {
        None
    };

    // Check for conflicting conditions
    if create && repo.local_branch_exists(&resolved_branch)? {
        return Err(GitError::BranchAlreadyExists {
            branch: resolved_branch.clone(),
        }
        .into());
    }

    // Warn if --create would shadow a remote branch
    if create {
        let remotes = repo.remotes_with_branch(&resolved_branch)?;
        if !remotes.is_empty() {
            let remote_ref = format!("{}/{}", remotes[0], resolved_branch);
            crate::output::print(warning_message(cformat!(
                "Branch <bold>{resolved_branch}</> exists on remote ({remote_ref}); creating new branch from base instead"
            )))?;
            let cmd = suggest_command("switch", &[&resolved_branch], &[]);
            crate::output::print(hint_message(cformat!(
                "To switch to the remote branch, remove <bright-black>--create</>; run <bright-black>{cmd}</>"
            )))?;
        }
    }

    // Check if base flag was provided without create flag
    if resolved_base.is_some() && !create {
        crate::output::print(warning_message(
            "--base flag is only used with --create, ignoring",
        ))?;
    }

    // Compute expected worktree path for this branch
    let expected_path = compute_worktree_path(&repo, &resolved_branch, config)?;

    // Helper to build switch result for an existing worktree.
    let switch_to_existing = |path: PathBuf| -> (SwitchResult, SwitchBranchInfo) {
        let canonical_path = canonicalize(&path).unwrap_or(path.clone());
        let current_dir = std::env::current_dir()
            .ok()
            .and_then(|p| canonicalize(&p).ok());
        let already_at_worktree = current_dir
            .as_ref()
            .map(|cur| cur == &canonical_path)
            .unwrap_or(false);

        // Check if the actual path matches the expected path.
        let canonical_expected = canonicalize(&expected_path).unwrap_or(expected_path.clone());
        let path_mismatch = if canonical_path != canonical_expected {
            Some(expected_path.clone())
        } else {
            None
        };

        let result = if already_at_worktree {
            SwitchResult::AlreadyAt(canonical_path)
        } else {
            SwitchResult::Existing(canonical_path)
        };
        let branch_info = SwitchBranchInfo {
            branch: resolved_branch.clone(),
            expected_path: path_mismatch,
        };
        (result, branch_info)
    };

    // Branch-first lookup: check if branch has a worktree anywhere
    match repo.worktree_for_branch(&resolved_branch)? {
        Some(existing_path) if existing_path.exists() => {
            let _ = repo.record_switch_previous(new_previous);
            return Ok(switch_to_existing(existing_path));
        }
        Some(_) => {
            return Err(GitError::WorktreeMissing {
                branch: resolved_branch.clone(),
            }
            .into());
        }
        None => {}
    }

    // No worktree for branch - check if expected path is occupied by a different branch's worktree
    if let Some((existing_path, path_branch)) = repo.worktree_at_path(&expected_path)? {
        if !existing_path.exists() {
            // Stale worktree metadata - git thinks there's a worktree but directory is gone
            let branch = path_branch.unwrap_or_else(|| resolved_branch.clone());
            return Err(GitError::WorktreeMissing { branch }.into());
        }

        // Path is occupied by a different branch's worktree
        return Err(GitError::WorktreePathOccupied {
            branch: resolved_branch.clone(),
            path: expected_path,
            occupant: path_branch,
        }
        .into());
    }

    // No existing worktree for branch or at expected path - will create one
    let worktree_path = expected_path;

    // If the target path already exists but is NOT a worktree (e.g., stale directory),
    // either move it to .bak (with --clobber) or surface a helpful error.
    if worktree_path.exists() {
        if clobber {
            use anyhow::Context;

            // Generate timestamped backup path
            let timestamp = worktrunk::utils::get_now() as i64;
            let datetime =
                chrono::DateTime::from_timestamp(timestamp, 0).unwrap_or_else(chrono::Utc::now);
            let suffix = datetime.format("%Y%m%d-%H%M%S").to_string();
            let backup_path = generate_backup_path(&worktree_path, &suffix);

            // Error if backup path already exists
            if backup_path.exists() {
                anyhow::bail!(
                    "Backup path already exists: {}",
                    worktrunk::path::format_path_for_display(&backup_path)
                );
            }

            let path_display = worktrunk::path::format_path_for_display(&worktree_path);
            let backup_display = worktrunk::path::format_path_for_display(&backup_path);
            crate::output::print(warning_message(cformat!(
                "Moving <bold>{path_display}</> to <bold>{backup_display}</> (<bright-black>--clobber</>)"
            )))?;

            std::fs::rename(&worktree_path, &backup_path)
                .with_context(|| format!("Failed to move {path_display} to {backup_display}"))?;
        } else {
            return Err(GitError::WorktreePathExists {
                branch: resolved_branch.clone(),
                path: worktree_path,
                create,
            }
            .into());
        }
    }

    // Create the worktree
    // Build git worktree add command
    let mut args = vec!["worktree", "add", worktree_path.to_str().unwrap()];

    // Use the resolved base, or default to default branch if creating without a base.
    // For bare repos with no branches yet (bootstrap case), allow None to create orphan branch.
    let base_for_creation = if create {
        match resolved_base {
            Some(b) => Some(b),
            None => repo.resolve_target_branch(None).ok(),
        }
    } else {
        None
    };

    // Build args based on whether we're creating or checking out
    if create {
        args.push("-b");
        args.push(&resolved_branch);
        if let Some(ref base_branch) = base_for_creation {
            args.push(base_branch);
        }
    } else {
        args.push(&resolved_branch);
    }

    // Create worktree and parse specific error cases
    if let Err(e) = repo.run_command(&args) {
        let msg = e.to_string();
        // Check if error is about directory already existing
        if msg.contains("already exists") {
            // Parse the path from git's error message
            // Format: "fatal: '/path/to/dir' already exists"
            if let Some(path_str) = msg
                .lines()
                .find(|line| line.contains("already exists"))
                .and_then(|line| {
                    // Extract path between quotes
                    line.split('\'').nth(1).or_else(|| line.split('"').nth(1))
                })
            {
                return Err(GitError::WorktreePathExists {
                    branch: resolved_branch.clone(),
                    path: std::path::PathBuf::from(path_str),
                    create,
                }
                .into());
            }
        }
        // Check if error is about invalid reference (branch not found)
        // Format: "fatal: invalid reference: branch-name"
        if msg.contains("invalid reference:") {
            return Err(GitError::InvalidReference {
                reference: resolved_branch.clone(),
            }
            .into());
        }
        // Fall back to generic error with context
        return Err(GitError::WorktreeCreationFailed {
            branch: resolved_branch.clone(),
            base_branch: base_for_creation.clone(),
            error: msg,
        }
        .into());
    }

    // Check if git's DWIM created a tracking branch from a remote
    // This happens when we don't use --create and the branch exists on a remote
    let from_remote = if !create {
        // Query the new worktree for its upstream tracking branch
        let worktree_repo = Repository::at(&worktree_path);
        worktree_repo.upstream_branch(&resolved_branch)?
    } else {
        None
    };

    // Execute post-create commands (sequential, blocking)
    // Note: If user declines, continue anyway - worktree already created
    if !no_verify {
        let repo_root = repo.worktree_base()?;
        let ctx = CommandContext::new(
            &repo,
            config,
            Some(&resolved_branch),
            &worktree_path,
            &repo_root,
            force,
        );
        // Approval was handled at the gate
        ctx.execute_post_create_commands()?;
    }

    // Note: post-start commands are spawned AFTER success message is shown
    // (see main.rs switch handler for temporal locality)

    // Record successful switch in history for `wt switch -` support
    let _ = repo.record_switch_previous(new_previous);

    Ok((
        SwitchResult::Created {
            path: worktree_path,
            created_branch: create,
            base_branch: base_for_creation,
            from_remote,
        },
        SwitchBranchInfo {
            branch: resolved_branch,
            expected_path: None, // Created at expected path by definition
        },
    ))
}

pub fn handle_remove(
    worktree_name: &str,
    no_delete_branch: bool,
    force_delete: bool,
    force_worktree: bool,
    background: bool,
) -> anyhow::Result<RemoveResult> {
    let repo = Repository::current();

    // Show progress (unless running in background - output handler will show command)
    if !background {
        crate::output::print(progress_message(cformat!(
            "Removing <bold>{worktree_name}</> worktree..."
        )))?;
    }

    repo.prepare_worktree_removal(
        RemoveTarget::Branch(worktree_name),
        BranchDeletionMode::from_flags(no_delete_branch, force_delete),
        force_worktree,
    )
}

/// Handle removing the current worktree (supports detached HEAD state).
///
/// This is the path-based removal that handles the "@" shorthand, including
/// when HEAD is detached.
pub fn handle_remove_current(
    no_delete_branch: bool,
    force_delete: bool,
    force_worktree: bool,
    background: bool,
) -> anyhow::Result<RemoveResult> {
    let repo = Repository::current();

    // Show progress (unless running in background - output handler will show command)
    if !background {
        crate::output::print(progress_message("Removing current worktree..."))?;
    }

    repo.prepare_worktree_removal(
        RemoveTarget::Current,
        BranchDeletionMode::from_flags(no_delete_branch, force_delete),
        force_worktree,
    )
}

/// Handle removing a worktree by path (for detached non-current worktrees).
///
/// This is used when a worktree is in detached HEAD state and we're not
/// currently in it. We can still remove the worktree, we just don't know
/// which branch (if any) to delete. Branch deletion is not attempted
/// since no branch is associated with a detached HEAD worktree.
pub fn handle_remove_by_path(
    path: &std::path::Path,
    branch: Option<String>,
    force_worktree: bool,
    background: bool,
) -> anyhow::Result<RemoveResult> {
    let repo = Repository::current();

    if !background {
        crate::output::print(progress_message(cformat!(
            "Removing worktree @ <bold>{}</>...",
            worktrunk::path::format_path_for_display(path)
        )))?;
    }

    // Check that the worktree is clean
    let target_repo = Repository::at(path);
    target_repo
        .ensure_clean_working_tree("remove worktree", branch.as_deref())
        .context("Failed to verify worktree status")?;

    // We're not in this worktree, so no directory change needed
    let current_path = repo
        .worktree_root()
        .context("Failed to determine current worktree")?
        .to_path_buf();

    Ok(RemoveResult::RemovedWorktree {
        main_path: current_path,
        worktree_path: path.to_path_buf(),
        changed_directory: false,
        branch_name: branch,
        deletion_mode: BranchDeletionMode::Keep, // Can't delete branch for detached worktree
        target_branch: None,
        integration_reason: None, // Not applicable for detached worktrees
        force_worktree,
    })
}

impl<'a> CommandContext<'a> {
    /// Execute post-create commands sequentially (blocking)
    ///
    /// Runs user hooks first, then project hooks.
    pub fn execute_post_create_commands(&self) -> anyhow::Result<()> {
        let project_config = self.repo.load_project_config()?;
        super::hooks::run_hook_with_filter(
            self,
            self.config.hooks.post_create.as_ref(),
            project_config
                .as_ref()
                .and_then(|c| c.hooks.post_create.as_ref()),
            HookType::PostCreate,
            &[],
            HookFailureStrategy::Warn,
            None,
            None, // No path display - running in expected directory
        )
    }

    /// Spawn post-start commands in parallel as background processes (non-blocking)
    ///
    /// `display_path`: When `Some`, shows the path in hook announcements. Pass this when
    /// the user's shell won't be in the worktree (shell integration not active).
    pub fn spawn_post_start_commands(
        &self,
        display_path: Option<&std::path::Path>,
    ) -> anyhow::Result<()> {
        let project_config = self.repo.load_project_config()?;

        let commands = prepare_hook_commands(
            self,
            self.config.hooks.post_start.as_ref(),
            project_config
                .as_ref()
                .and_then(|c| c.hooks.post_start.as_ref()),
            HookType::PostStart,
            &[],
            None,
            display_path,
        )?;

        spawn_hook_commands_background(self, commands, HookType::PostStart)
    }

    /// Spawn post-switch commands in parallel as background processes (non-blocking)
    ///
    /// Runs on every switch, including to existing worktrees and newly created ones.
    ///
    /// `display_path`: When `Some`, shows the path in hook announcements. Pass this when
    /// the user's shell won't be in the worktree (shell integration not active).
    pub fn spawn_post_switch_commands(
        &self,
        display_path: Option<&std::path::Path>,
    ) -> anyhow::Result<()> {
        let project_config = self.repo.load_project_config()?;

        let commands = prepare_hook_commands(
            self,
            self.config.hooks.post_switch.as_ref(),
            project_config
                .as_ref()
                .and_then(|c| c.hooks.post_switch.as_ref()),
            HookType::PostSwitch,
            &[],
            None,
            display_path,
        )?;

        spawn_hook_commands_background(self, commands, HookType::PostSwitch)
    }
}

/// Push changes to target branch
///
/// The `operations` parameter indicates which merge operations occurred (commit, squash, rebase).
/// Pass `None` for standalone push operations where these concepts don't apply.
///
/// During the push stage we temporarily `git stash` non-overlapping changes in the
/// target worktree (if present) so that concurrent edits there do not block the
/// fast-forward. The stash is restored afterward and we bail out early if any file
/// overlaps with the push range.
pub fn handle_push(
    target: Option<&str>,
    verb: &str,
    operations: Option<MergeOperations>,
) -> anyhow::Result<()> {
    let repo = Repository::current();

    // Get target branch (default to default branch if not provided)
    let target_branch = repo.resolve_target_branch(target)?;

    // A worktree for the target branch is optional for push:
    // - If present, we use it to check for overlapping dirty files.
    // - If absent, we skip that safety step but still allow the push (git itself is fine).
    let target_worktree_path = repo.worktree_for_branch(&target_branch)?;

    // Check if it's a fast-forward
    if !repo.is_ancestor(&target_branch, "HEAD")? {
        // Get formatted commit log (commits in target that we don't have)
        let commits_formatted = repo
            .run_command(&[
                "log",
                "--color=always",
                "--graph",
                "--oneline",
                &format!("HEAD..{}", target_branch),
            ])?
            .trim()
            .to_string();

        return Err(GitError::NotFastForward {
            target_branch: target_branch.clone(),
            commits_formatted,
            in_merge_context: operations.is_some(),
        }
        .into());
    }

    // Check for conflicting changes in target worktree (auto-stash safe changes)
    let mut target_worktree_stash =
        repo.prepare_target_worktree(target_worktree_path.as_ref(), &target_branch)?;

    // Count commits and show what will be pushed
    let commit_count = repo.count_commits(&target_branch, "HEAD")?;

    // Get diff statistics BEFORE push (will be needed for success message later)
    let stats_summary = if commit_count > 0 {
        repo.diff_stats_summary(&["diff", "--shortstat", &format!("{}..HEAD", target_branch)])
    } else {
        Vec::new()
    };

    // Build and show consolidated message with squash/rebase info
    if commit_count > 0 {
        let commit_text = if commit_count == 1 {
            "commit"
        } else {
            "commits"
        };
        let head_sha = repo.run_command(&["rev-parse", "--short", "HEAD"])?;
        let head_sha = head_sha.trim();

        let verb_ing = if verb.starts_with("Merged") {
            "Merging"
        } else {
            "Pushing"
        };

        // Build parenthetical showing which operations didn't happen and flags used
        let mut notes = Vec::new();

        // Skipped operations - only include if we're in merge workflow context
        if let Some(ops) = operations {
            let mut skipped_ops = Vec::new();
            if !ops.committed && !ops.squashed {
                // Neither commit nor squash happened - combine them
                skipped_ops.push("commit/squash");
            }
            if !ops.rebased {
                skipped_ops.push("rebase");
            }
            if !skipped_ops.is_empty() {
                notes.push(format!("no {} needed", skipped_ops.join("/")));
            }
        }

        let operations_note = if notes.is_empty() {
            String::new()
        } else {
            format!(" ({})", notes.join(", "))
        };

        crate::output::print(progress_message(cformat!(
            "{verb_ing} {commit_count} {commit_text} to <bold>{target_branch}</> @ <dim>{head_sha}</>{operations_note}"
        )))?;

        // Show the commit graph with color
        let log_output = repo.run_command(&[
            "log",
            "--color=always",
            "--graph",
            "--oneline",
            &format!("{}..HEAD", target_branch),
        ])?;
        crate::output::print(format_with_gutter(&log_output, None))?;

        // Show diff statistics
        super::show_diffstat(&repo, &format!("{}..HEAD", target_branch))?;
    }

    // Get git common dir for the push
    let git_common_dir = repo.git_common_dir()?;

    // Perform the push
    // Use --receive-pack to pass config to the receiving end without permanently mutating repo config
    let push_target = format!("HEAD:{}", target_branch);
    if let Err(e) = repo.run_command(&[
        "push",
        "--receive-pack=git -c receive.denyCurrentBranch=updateInstead receive-pack",
        git_common_dir.to_str().unwrap(),
        &push_target,
    ]) {
        if let Some(stash) = target_worktree_stash.take() {
            stash.restore()?;
        }
        // CommandFailed contains raw git output, wrap in PushFailed for proper formatting
        return Err(GitError::PushFailed {
            target_branch: target_branch.clone(),
            error: e.to_string(),
        }
        .into());
    }

    if let Some(stash) = target_worktree_stash.take() {
        stash.restore()?;
    }

    // Show success message after push completes
    if commit_count > 0 {
        // Use the diff statistics captured earlier (before push)
        let mut summary_parts = vec![format!(
            "{} commit{}",
            commit_count,
            if commit_count == 1 { "" } else { "s" }
        )];
        summary_parts.extend(stats_summary);

        // Re-apply bright-black after stats (which end with a reset) so ) is also gray
        let stats_str = summary_parts.join(", ");
        let paren_close = cformat!("<bright-black>)</>"); // Separate to avoid cformat optimization
        crate::output::print(success_message(cformat!(
            "{verb} <bold>{target_branch}</> <bright-black>({stats_str}</>{}",
            paren_close
        )))?;
    } else {
        // For merge workflow context, explain why nothing was pushed
        let context = if let Some(ops) = operations {
            let mut notes = Vec::new();
            if !ops.committed && !ops.squashed {
                notes.push("no new commits");
            }
            if !ops.rebased {
                notes.push("no rebase needed");
            }
            if notes.is_empty() {
                String::new()
            } else {
                format!(" ({})", notes.join(", "))
            }
        } else {
            String::new()
        };

        // No action: nothing was pushed, just acknowledging state
        crate::output::print(info_message(cformat!(
            "Already up to date with <bold>{target_branch}</>{context}"
        )))?;
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_switch_result_path_already_at() {
        let path = PathBuf::from("/test/path");
        let result = SwitchResult::AlreadyAt(path.clone());
        assert_eq!(result.path(), &path);
    }

    #[test]
    fn test_switch_result_path_existing() {
        let path = PathBuf::from("/test/existing");
        let result = SwitchResult::Existing(path.clone());
        assert_eq!(result.path(), &path);
    }

    #[test]
    fn test_switch_result_path_created() {
        let path = PathBuf::from("/test/created");
        let result = SwitchResult::Created {
            path: path.clone(),
            created_branch: true,
            base_branch: Some("main".to_string()),
            from_remote: None,
        };
        assert_eq!(result.path(), &path);
    }

    #[test]
    fn test_switch_result_created_with_remote() {
        let path = PathBuf::from("/test/remote");
        let result = SwitchResult::Created {
            path: path.clone(),
            created_branch: false,
            base_branch: None,
            from_remote: Some("origin/feature".to_string()),
        };
        assert_eq!(result.path(), &path);
    }

    #[test]
    fn test_merge_operations_struct() {
        let ops = MergeOperations {
            committed: true,
            squashed: false,
            rebased: true,
        };
        assert!(ops.committed);
        assert!(!ops.squashed);
        assert!(ops.rebased);
    }

    #[test]
    fn test_merge_operations_clone() {
        let ops = MergeOperations {
            committed: true,
            squashed: true,
            rebased: false,
        };
        // MergeOperations implements both Clone and Copy
        // Use Clone explicitly to test the Clone impl
        let cloned = Clone::clone(&ops);
        assert_eq!(ops.committed, cloned.committed);
        assert_eq!(ops.squashed, cloned.squashed);
        assert_eq!(ops.rebased, cloned.rebased);
    }

    #[test]
    fn test_merge_operations_copy() {
        let ops = MergeOperations {
            committed: false,
            squashed: false,
            rebased: true,
        };
        let copied = ops; // Copy trait
        assert_eq!(ops.committed, copied.committed);
        assert_eq!(ops.squashed, copied.squashed);
        assert_eq!(ops.rebased, copied.rebased);
    }

    #[test]
    fn test_merge_operations_debug() {
        let ops = MergeOperations {
            committed: true,
            squashed: false,
            rebased: true,
        };
        let debug = format!("{:?}", ops);
        assert!(debug.contains("committed: true"));
        assert!(debug.contains("squashed: false"));
        assert!(debug.contains("rebased: true"));
    }

    #[test]
    fn test_remove_result_removed_worktree() {
        let result = RemoveResult::RemovedWorktree {
            main_path: PathBuf::from("/main"),
            worktree_path: PathBuf::from("/worktree"),
            changed_directory: true,
            branch_name: Some("feature".to_string()),
            deletion_mode: BranchDeletionMode::SafeDelete,
            target_branch: Some("main".to_string()),
            integration_reason: Some(worktrunk::git::IntegrationReason::SameCommit),
            force_worktree: false,
        };
        match result {
            RemoveResult::RemovedWorktree {
                main_path,
                worktree_path,
                changed_directory,
                branch_name,
                deletion_mode,
                target_branch,
                integration_reason,
                force_worktree,
            } => {
                assert_eq!(main_path.to_str().unwrap(), "/main");
                assert_eq!(worktree_path.to_str().unwrap(), "/worktree");
                assert!(changed_directory);
                assert_eq!(branch_name.as_deref(), Some("feature"));
                assert!(!deletion_mode.should_keep());
                assert!(!deletion_mode.is_force());
                assert_eq!(target_branch.as_deref(), Some("main"));
                assert!(integration_reason.is_some());
                assert!(!force_worktree);
            }
            _ => panic!("Expected RemovedWorktree variant"),
        }
    }

    #[test]
    fn test_remove_result_branch_only() {
        let result = RemoveResult::BranchOnly {
            branch_name: "stale-branch".to_string(),
            deletion_mode: BranchDeletionMode::Keep,
        };
        match result {
            RemoveResult::BranchOnly {
                branch_name,
                deletion_mode,
            } => {
                assert_eq!(branch_name, "stale-branch");
                assert!(deletion_mode.should_keep());
                assert!(!deletion_mode.is_force());
            }
            _ => panic!("Expected BranchOnly variant"),
        }
    }

    #[test]
    fn test_remove_result_with_force_delete() {
        let result = RemoveResult::RemovedWorktree {
            main_path: PathBuf::from("/main"),
            worktree_path: PathBuf::from("/worktree"),
            changed_directory: false,
            branch_name: None, // Detached HEAD
            deletion_mode: BranchDeletionMode::ForceDelete,
            target_branch: None,
            integration_reason: None, // Force delete skips integration check
            force_worktree: true,
        };
        match result {
            RemoveResult::RemovedWorktree {
                branch_name,
                deletion_mode,
                force_worktree,
                ..
            } => {
                assert!(branch_name.is_none());
                assert!(deletion_mode.is_force());
                assert!(force_worktree);
            }
            _ => panic!("Expected RemovedWorktree variant"),
        }
    }

    #[test]
    fn test_generate_backup_path_with_extension() {
        // Paths with extensions: file.txt -> file.txt.bak.TIMESTAMP
        let path = PathBuf::from("/tmp/repo.feature");
        let backup = super::generate_backup_path(&path, "20250101-000000");
        assert_eq!(
            backup,
            PathBuf::from("/tmp/repo.feature.bak.20250101-000000")
        );

        let path = PathBuf::from("/tmp/file.txt");
        let backup = super::generate_backup_path(&path, "20250101-000000");
        assert_eq!(backup, PathBuf::from("/tmp/file.txt.bak.20250101-000000"));
    }

    #[test]
    fn test_generate_backup_path_without_extension() {
        // Paths without extensions: foo -> foo.bak.TIMESTAMP
        let path = PathBuf::from("/tmp/repo/feature");
        let backup = super::generate_backup_path(&path, "20250101-000000");
        assert_eq!(
            backup,
            PathBuf::from("/tmp/repo/feature.bak.20250101-000000")
        );

        let path = PathBuf::from("/tmp/mydir");
        let backup = super::generate_backup_path(&path, "20250101-000000");
        assert_eq!(backup, PathBuf::from("/tmp/mydir.bak.20250101-000000"));
    }
}
