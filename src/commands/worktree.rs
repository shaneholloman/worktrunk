//! Worktree operations with dual-mode output for shell integration.
//!
//! # The Directory Change Problem
//!
//! Worktree commands (`switch`, `remove`, `merge`) need to change the user's working directory,
//! but there's a fundamental Unix limitation: **child processes cannot change their parent's
//! working directory**. This is a security feature and core Unix design principle.
//!
//! When a user runs `wt switch my-feature`, the `wt` binary runs as a child process of the shell.
//! The binary can change *its own* working directory, but when it exits, the parent shell remains
//! in the original directory.
//!
//! # Solution: Dual-Mode Output
//!
//! We solve this with two output modes:
//!
//! ## Without `--internal` (Direct Binary Call)
//!
//! ```bash
//! $ wt switch my-feature
//! Created new branch and worktree for 'my-feature' at /path/to/worktree
//!
//! To enable automatic cd, run: wt config shell
//!
//! $ pwd
//! /original/directory  # ← User is still here!
//! ```
//!
//! The binary performs git operations and prints user-friendly messages, but **cannot** change
//! the parent shell's directory. User must manually `cd` to the worktree.
//!
//! ## With `--internal` (Via Shell Wrapper)
//!
//! ```bash
//! $ wt switch my-feature
//! Created new branch and worktree for 'my-feature' at /path/to/worktree
//!
//! $ pwd
//! /path/to/worktree  # ← Automatically changed!
//! ```
//!
//! When shell integration is enabled (`eval "$(wt init bash)"`), the shell function intercepts
//! commands and adds `--internal`:
//!
//! 1. Shell wrapper calls: `wt switch --internal my-feature`
//! 2. Binary outputs special directive protocol:
//!    ```text
//!    __WORKTRUNK_CD__/path/to/worktree
//!    Created new branch and worktree for 'my-feature' at /path/to/worktree
//!    ```
//! 3. Shell wrapper parses output line-by-line
//! 4. When it sees `__WORKTRUNK_CD__<path>`, it executes `cd <path>` in the parent shell
//! 5. Other lines are printed normally
//!
//! The binary **never changes directories itself** - it just communicates the desired path back
//! to the shell wrapper via stdout using the `__WORKTRUNK_CD__` directive protocol.
//!
//! # Implementation Details
//!
//! Result types (`SwitchResult`, `RemoveResult`) are pure data structures that only contain
//! operation results. All presentation logic is handled by the `output` module:
//!
//! - `output::handle_switch_output()`: Formats and outputs switch operation results
//! - `output::handle_remove_output()`: Formats and outputs remove operation results
//!
//! These handlers automatically select the appropriate mode (user-friendly or directive protocol)
//! based on the `internal` flag
//!
//! ## Directive Protocol
//!
//! Directives are NUL-terminated to support multi-line commands (e.g., via `-x` flag):
//!
//! ```text
//! __WORKTRUNK_CD__/path/to/worktree\0
//! Message for user\0
//! __WORKTRUNK_EXEC__echo 'line1'\necho 'line2'\0
//! ```
//!
//! Shell wrappers split on `\0` bytes and process each chunk:
//! - `__WORKTRUNK_CD__<path>`: Change directory to `<path>`
//! - `__WORKTRUNK_EXEC__<command>`: Execute `<command>` (may contain newlines)
//! - Other chunks: Print as regular output
//!
//! ## Exit Code Semantics
//!
//! When using `-x` to execute commands after switching:
//!
//! - **Exit code returned**: The `wt` command's exit code
//! - **Command execution**: Runs for side effects; failures are logged but don't affect exit code
//! - **Rationale**: Allows scripts to detect `wt` failures (e.g., branch already exists) while
//!   still executing post-switch commands for convenience
//!
//! Example:
//! ```bash
//! wt switch --create feature -x "editor ."  # Opens editor even if branch exists
//! echo $?  # Returns wt's exit code, not editor's
//! ```
//!
//! The shell wrapper is generated by `wt init <shell>` from templates in `templates/`.

use std::path::PathBuf;
use worktrunk::config::{CommandPhase, WorktrunkConfig};
use worktrunk::git::{GitError, GitResultExt, Repository};
use worktrunk::styling::{
    CYAN, CYAN_BOLD, GREEN, GREEN_BOLD, WARNING, WARNING_BOLD, format_bash_with_gutter,
    format_with_gutter,
};

use super::command_executor::{CommandContext, prepare_project_commands};
use super::project_config::load_project_config;
use crate::commands::process::spawn_detached;
use crate::output::execute_command_in_worktree;

/// Result of a worktree switch operation
pub enum SwitchResult {
    /// Switched to existing worktree at the given path
    ExistingWorktree(PathBuf),
    /// Created new worktree at the given path
    CreatedWorktree {
        path: PathBuf,
        created_branch: bool,
        base_branch: Option<String>,
    },
}

impl SwitchResult {
    /// Get the worktree path
    pub fn path(&self) -> &PathBuf {
        match self {
            SwitchResult::ExistingWorktree(path) => path,
            SwitchResult::CreatedWorktree { path, .. } => path,
        }
    }
}

/// Result of a worktree remove operation
pub enum RemoveResult {
    /// Already on default branch, no action taken
    AlreadyOnDefault(String),
    /// Removed worktree and returned to primary (if needed)
    RemovedWorktree {
        primary_path: PathBuf,
        worktree_path: PathBuf,
        changed_directory: bool,
        branch_name: String,
        no_delete_branch: bool,
    },
    /// Switched to default branch in main repo
    SwitchedToDefault(String),
}

pub fn handle_switch(
    branch: &str,
    create: bool,
    base: Option<&str>,
    force: bool,
    no_verify: bool,
    config: &WorktrunkConfig,
) -> Result<(SwitchResult, String), GitError> {
    let repo = Repository::current();

    // Resolve special branch names ("@" for current, "-" for previous)
    let resolved_branch = repo.resolve_worktree_name(branch)?;

    // Resolve base if provided
    let resolved_base = if let Some(base_str) = base {
        Some(repo.resolve_worktree_name(base_str)?)
    } else {
        None
    };

    // Check for conflicting conditions
    if create && repo.local_branch_exists(&resolved_branch)? {
        return Err(GitError::BranchAlreadyExists {
            branch: resolved_branch.clone(),
        });
    }

    // Check if base flag was provided without create flag
    if resolved_base.is_some() && !create {
        crate::output::warning(format!(
            "{WARNING}--base flag is only used with --create, ignoring{WARNING:#}"
        ))?;
    }

    // Check if worktree already exists for this branch
    match repo.worktree_for_branch(&resolved_branch)? {
        Some(existing_path) if existing_path.exists() => {
            // Canonicalize the path for cleaner display
            let canonical_existing_path = existing_path.canonicalize().unwrap_or(existing_path);
            return Ok((
                SwitchResult::ExistingWorktree(canonical_existing_path),
                resolved_branch,
            ));
        }
        Some(_) => {
            return Err(GitError::WorktreeMissing {
                branch: resolved_branch.clone(),
            });
        }
        None => {}
    }

    // No existing worktree, create one
    let repo_root = repo.worktree_base()?;

    let repo_name = repo_root
        .file_name()
        .ok_or_else(|| GitError::CommandFailed("Invalid repository path".to_string()))?
        .to_str()
        .ok_or_else(|| GitError::CommandFailed("Invalid UTF-8 in path".to_string()))?;

    let worktree_path = repo_root.join(config.format_path(repo_name, &resolved_branch));

    // Create the worktree
    // Build git worktree add command
    let mut args = vec!["worktree", "add", worktree_path.to_str().unwrap()];

    // Use the resolved base, or default to default branch if creating without a base
    let base_for_creation = if create {
        match resolved_base {
            Some(b) => Some(b),
            None => Some(repo.resolve_target_branch(None)?),
        }
    } else {
        None
    };

    // Build args based on whether we're creating or checking out
    if create {
        args.push("-b");
        args.push(&resolved_branch);
        if let Some(ref base_branch) = base_for_creation {
            args.push(base_branch);
        }
    } else {
        args.push(&resolved_branch);
    }

    // Create worktree and parse specific error cases
    if let Err(e) = repo.run_command(&args) {
        // Check if error is about directory already existing
        if let GitError::CommandFailed(ref msg) = e
            && msg.contains("already exists")
        {
            // Parse the path from git's error message
            // Format: "fatal: '/path/to/dir' already exists"
            if let Some(path_str) = msg
                .lines()
                .find(|line| line.contains("already exists"))
                .and_then(|line| {
                    // Extract path between quotes
                    line.split('\'').nth(1).or_else(|| line.split('"').nth(1))
                })
            {
                let path = std::path::PathBuf::from(path_str);
                // Canonicalize if possible, otherwise use as-is
                let normalized_path = path.canonicalize().unwrap_or(path);
                return Err(GitError::WorktreePathExists {
                    path: normalized_path,
                });
            }
        }
        // Fall back to generic error with context
        return Err(e).git_context("Failed to create worktree");
    }

    // Canonicalize the path to resolve any .. components
    let worktree_path = worktree_path
        .canonicalize()
        .git_context("Failed to canonicalize worktree path")?;

    // Execute post-create commands (sequential, blocking)
    // Note: If user declines, continue anyway - worktree already created
    if !no_verify
        && let Err(e) =
            execute_post_create_commands(&worktree_path, &repo, config, &resolved_branch, force)
    {
        // Only treat CommandNotApproved as non-fatal (user declined)
        // Other errors should still fail
        if !matches!(e, GitError::CommandNotApproved) {
            return Err(e);
        }
    }

    // Note: post-start commands are spawned AFTER success message is shown
    // (see main.rs switch handler for temporal locality)

    Ok((
        SwitchResult::CreatedWorktree {
            path: worktree_path,
            created_branch: create,
            base_branch: base_for_creation,
        },
        resolved_branch,
    ))
}

pub fn handle_remove(
    worktree_name: Option<&str>,
    no_delete_branch: bool,
) -> Result<RemoveResult, GitError> {
    let repo = Repository::current();

    // Resolve "@" to current branch early so progress message shows resolved name
    let resolved_name = if let Some(name) = worktree_name {
        Some(repo.resolve_worktree_name(name)?)
    } else {
        None
    };

    // Show progress with resolved name
    let progress_msg = if let Some(ref b) = resolved_name {
        format!("{CYAN}Removing worktree for {CYAN_BOLD}{b}{CYAN_BOLD:#}...{CYAN:#}")
    } else {
        format!("{CYAN}Removing worktree...{CYAN:#}")
    };
    crate::output::progress(progress_msg)?;

    // Two modes: remove current worktree vs. remove by name
    match resolved_name.as_deref() {
        None => remove_current_worktree(&repo, no_delete_branch),
        Some(name) => remove_worktree_by_name(&repo, name, no_delete_branch),
    }
}

/// Remove the current worktree (original behavior)
fn remove_current_worktree(
    repo: &Repository,
    no_delete_branch: bool,
) -> Result<RemoveResult, GitError> {
    // Check for uncommitted changes in current worktree
    repo.ensure_clean_working_tree()?;

    // Check if we're in a worktree (fast - just checks git metadata)
    let in_worktree = repo.is_in_worktree()?;

    if in_worktree {
        // In worktree: navigate to primary worktree and remove this one
        // (no need to check default branch in this path)
        let worktree_root = repo.worktree_root()?;
        let current_branch = repo
            .current_branch()?
            .ok_or_else(|| GitError::CommandFailed("Not on a branch".to_string()))?;
        let worktrees = repo.list_worktrees()?;
        let primary_worktree_dir = worktrees.worktrees[0].path.clone();

        // Return paths - deletion will happen in output handler after cd directive is emitted
        Ok(RemoveResult::RemovedWorktree {
            primary_path: primary_worktree_dir,
            worktree_path: worktree_root,
            changed_directory: true, // We're in the worktree being removed
            branch_name: current_branch,
            no_delete_branch,
        })
    } else {
        // In main repo: check if already on default branch
        // Only fetch default_branch if needed (can be slow - network call)
        let current_branch = repo.current_branch()?;
        let default_branch = repo.default_branch()?;

        if current_branch.as_deref() == Some(&default_branch) {
            return Ok(RemoveResult::AlreadyOnDefault(default_branch));
        }

        // Switch to default branch
        repo.run_command(&["switch", &default_branch])
            .git_context(&format!("Failed to switch to '{}'", default_branch))?;

        Ok(RemoveResult::SwitchedToDefault(default_branch))
    }
}

/// Remove a worktree by branch name (branch_name should already be resolved)
fn remove_worktree_by_name(
    repo: &Repository,
    branch_name: &str,
    no_delete_branch: bool,
) -> Result<RemoveResult, GitError> {
    // Find the worktree for this branch
    let worktree_path = repo.worktree_for_branch(branch_name)?;

    let worktree_path = match worktree_path {
        Some(path) => path,
        None => {
            return Err(GitError::NoWorktreeFound {
                branch: branch_name.to_string(),
            });
        }
    };

    // Check if the target worktree exists on disk
    if !worktree_path.exists() {
        return Err(GitError::WorktreeMissing {
            branch: branch_name.to_string(),
        });
    }

    // Check if the target worktree is clean (no uncommitted changes)
    let target_repo = Repository::at(&worktree_path);
    target_repo.ensure_clean_working_tree()?;

    // Get the current worktree root to check if we're removing ourselves
    let current_worktree = repo.worktree_root()?;
    let removing_current = current_worktree == worktree_path;

    // Return paths for all cases - deletion happens in output handler
    let (primary_path, changed_directory) = if removing_current {
        // Removing current worktree - will cd to primary worktree
        let worktrees = repo.list_worktrees()?;
        (worktrees.worktrees[0].path.clone(), true)
    } else {
        // Removing different worktree - stay in current location
        (repo.worktree_root()?, false)
    };

    Ok(RemoveResult::RemovedWorktree {
        primary_path,
        worktree_path,
        changed_directory,
        branch_name: branch_name.to_string(),
        no_delete_branch,
    })
}

/// Check for conflicting uncommitted changes in target worktree
fn check_worktree_conflicts(
    repo: &Repository,
    target_worktree: &Option<std::path::PathBuf>,
    target_branch: &str,
) -> Result<(), GitError> {
    let Some(wt_path) = target_worktree else {
        return Ok(());
    };

    let wt_repo = Repository::at(wt_path);
    if !wt_repo.is_dirty()? {
        return Ok(());
    }

    // Get files changed in the push
    let push_files = repo.changed_files(target_branch, "HEAD")?;

    // Get files changed in the worktree
    let wt_status_output = wt_repo.run_command(&["status", "--porcelain"])?;

    let wt_files: Vec<String> = wt_status_output
        .lines()
        .filter_map(|line| {
            // Parse porcelain format: "XY filename"
            line.split_once(' ')
                .map(|(_, filename)| filename.trim().to_string())
        })
        .collect();

    // Find overlapping files
    let overlapping: Vec<String> = push_files
        .iter()
        .filter(|f| wt_files.contains(f))
        .cloned()
        .collect();

    if !overlapping.is_empty() {
        return Err(GitError::ConflictingChanges {
            files: overlapping,
            worktree_path: wt_path.to_path_buf(),
        });
    }

    Ok(())
}

/// Execute post-create commands sequentially (blocking)
pub fn execute_post_create_commands(
    worktree_path: &std::path::Path,
    repo: &Repository,
    config: &WorktrunkConfig,
    branch: &str,
    force: bool,
) -> Result<(), GitError> {
    let project_config = match load_project_config(repo)? {
        Some(cfg) => cfg,
        None => return Ok(()),
    };

    let Some(post_create_config) = &project_config.post_create_command else {
        return Ok(());
    };

    let repo_root = repo.worktree_base()?;
    let ctx = CommandContext::new(repo, config, branch, worktree_path, &repo_root, force);
    let commands = prepare_project_commands(
        post_create_config,
        &ctx,
        false,
        &[],
        CommandPhase::PostCreate,
    )?;

    if commands.is_empty() {
        return Ok(());
    }

    // Execute each command sequentially
    for prepared in commands {
        let label = crate::commands::format_command_label("post-create", prepared.name.as_deref());
        crate::output::progress(format!("{CYAN}{label}:{CYAN:#}"))?;
        crate::output::gutter(format_bash_with_gutter(&prepared.expanded, ""))?;

        if let Err(e) = execute_command_in_worktree(worktree_path, &prepared.expanded) {
            let message = match &prepared.name {
                Some(name) => format!(
                    "{WARNING}Command {WARNING_BOLD}{name}{WARNING_BOLD:#} failed: {e}{WARNING:#}"
                ),
                None => format!("{WARNING}Command failed: {e}{WARNING:#}"),
            };
            crate::output::warning(message)?;
            // Continue with other commands even if one fails
        }
    }

    crate::output::flush()?;

    Ok(())
}

/// Spawn post-start commands in parallel as background processes (non-blocking)
pub fn spawn_post_start_commands(
    worktree_path: &std::path::Path,
    repo: &Repository,
    config: &WorktrunkConfig,
    branch: &str,
    force: bool,
) -> Result<(), GitError> {
    let project_config = match load_project_config(repo)? {
        Some(cfg) => cfg,
        None => return Ok(()),
    };

    let Some(post_start_config) = &project_config.post_start_command else {
        return Ok(());
    };

    let repo_root = repo.worktree_base()?;
    let ctx = CommandContext::new(repo, config, branch, worktree_path, &repo_root, force);
    let commands =
        prepare_project_commands(post_start_config, &ctx, false, &[], CommandPhase::PostStart)?;

    if commands.is_empty() {
        return Ok(());
    }

    // Spawn each command as a detached background process
    for prepared in commands {
        let label = crate::commands::format_command_label("post-start", prepared.name.as_deref());
        crate::output::progress(format!("{CYAN}{label}:{CYAN:#}"))?;
        crate::output::gutter(format_bash_with_gutter(&prepared.expanded, ""))?;

        let name = prepared.name.as_deref().unwrap_or("cmd");
        match spawn_detached(worktree_path, &prepared.expanded, name) {
            Ok(_log_path) => {
                // Background command spawned successfully
                // Log file path not shown - only needed for debugging failures
            }
            Err(e) => {
                let message = match &prepared.name {
                    Some(name) => {
                        format!("{WARNING}Failed to spawn '{name}': {e}{WARNING:#}")
                    }
                    None => {
                        format!("{WARNING}Failed to spawn command: {e}{WARNING:#}")
                    }
                };
                crate::output::warning(message)?;
            }
        }
    }

    crate::output::flush()?;

    Ok(())
}

/// Execute post-start commands sequentially (blocking) - for testing
pub fn execute_post_start_commands_sequential(
    worktree_path: &std::path::Path,
    repo: &Repository,
    config: &WorktrunkConfig,
    branch: &str,
    force: bool,
) -> Result<(), GitError> {
    let project_config = match load_project_config(repo)? {
        Some(cfg) => cfg,
        None => return Ok(()),
    };

    let Some(post_start_config) = &project_config.post_start_command else {
        return Ok(());
    };

    let repo_root = repo.worktree_base()?;
    let ctx = CommandContext::new(repo, config, branch, worktree_path, &repo_root, force);
    let commands =
        prepare_project_commands(post_start_config, &ctx, false, &[], CommandPhase::PostStart)?;

    if commands.is_empty() {
        return Ok(());
    }

    // Execute sequentially for testing
    for prepared in commands {
        let label = crate::commands::format_command_label("post-start", prepared.name.as_deref());
        crate::output::progress(format!("{CYAN}{label}:{CYAN:#}"))?;
        crate::output::gutter(format_bash_with_gutter(&prepared.expanded, ""))?;

        if let Err(e) = execute_command_in_worktree(worktree_path, &prepared.expanded) {
            let message = match &prepared.name {
                Some(name) => {
                    format!("{WARNING}Failed to execute '{name}': {e}{WARNING:#}")
                }
                None => format!("{WARNING}Command failed: {e}{WARNING:#}"),
            };
            crate::output::warning(message)?;
        }
    }

    crate::output::flush()?;

    Ok(())
}

pub fn handle_push(
    target: Option<&str>,
    allow_merge_commits: bool,
    verb: &str,
    committed: bool,
    squashed: bool,
    rebased: bool,
) -> Result<(), GitError> {
    let repo = Repository::current();

    // Get target branch (default to default branch if not provided)
    let target_branch = repo.resolve_target_branch(target)?;

    // Check if it's a fast-forward
    if !repo.is_ancestor(&target_branch, "HEAD")? {
        // Get formatted commit log (commits in target that we don't have)
        let commits_formatted = repo
            .run_command(&[
                "log",
                "--color=always",
                "--graph",
                "--oneline",
                "--decorate",
                &format!("HEAD..{}", target_branch),
            ])?
            .trim()
            .to_string();

        // Get formatted diff stat
        let term_width = crate::display::get_terminal_width();
        let files_formatted = repo
            .run_command(&[
                "diff",
                "--color=always",
                "--stat",
                &format!("--stat-width={}", term_width),
                &format!("HEAD...{}", target_branch),
            ])?
            .trim_end()
            .to_string();

        return Err(GitError::NotFastForward {
            target_branch: target_branch.to_string(),
            commits_formatted,
            files_formatted,
        });
    }

    // Check for merge commits unless allowed
    let has_merge_commits = repo.has_merge_commits(&target_branch, "HEAD")?;
    if !allow_merge_commits && has_merge_commits {
        return Err(GitError::MergeCommitsFound);
    }

    // Configure receive.denyCurrentBranch if needed
    let current_config = repo.get_config("receive.denyCurrentBranch")?;
    if current_config.as_deref() != Some("updateInstead") {
        repo.set_config("receive.denyCurrentBranch", "updateInstead")?;
    }

    // Check for conflicting changes in target worktree
    let target_worktree = repo.worktree_for_branch(&target_branch)?;
    check_worktree_conflicts(&repo, &target_worktree, &target_branch)?;

    // Count commits and show what will be pushed
    let commit_count = repo.count_commits(&target_branch, "HEAD")?;

    // Get diff statistics BEFORE push (will be needed for success message later)
    let stats_summary = if commit_count > 0 {
        repo.diff_stats_summary(&["diff", "--shortstat", &format!("{}..HEAD", target_branch)])
    } else {
        Vec::new()
    };

    // Build and show consolidated message with squash/rebase info
    if commit_count > 0 {
        let commit_text = if commit_count == 1 {
            "commit"
        } else {
            "commits"
        };
        let head_sha = repo.run_command(&["rev-parse", "--short", "HEAD"])?;
        let head_sha = head_sha.trim();

        let verb_ing = if verb.starts_with("Merged") {
            "Merging"
        } else {
            "Pushing"
        };

        let cyan_dim = CYAN.dimmed();

        // Build parenthetical showing which operations didn't happen and flags used
        let mut notes = Vec::new();

        // Skipped operations
        let mut skipped_ops = Vec::new();
        if !committed && !squashed {
            // Neither commit nor squash happened - combine them
            skipped_ops.push("commit/squash");
        }
        if !rebased {
            skipped_ops.push("rebase");
        }
        if !skipped_ops.is_empty() {
            notes.push(format!("no {} needed", skipped_ops.join("/")));
        }

        // Flag acknowledgments
        if allow_merge_commits && has_merge_commits {
            notes.push("merge commits allowed".to_string());
        }

        let operations_note = if notes.is_empty() {
            String::new()
        } else {
            format!(" ({})", notes.join(", "))
        };

        crate::output::progress(format!(
            "{CYAN}{verb_ing} {commit_count} {commit_text} to {CYAN_BOLD}{target_branch}{CYAN_BOLD:#}{CYAN} @ {cyan_dim}{head_sha}{cyan_dim:#}{CYAN:#}{operations_note}\n"
        ))?;

        // Show the commit graph with color
        let log_output = repo.run_command(&[
            "log",
            "--color=always",
            "--graph",
            "--oneline",
            "--decorate",
            &format!("{}..HEAD", target_branch),
        ])?;
        crate::output::gutter(format_with_gutter(&log_output, "", None))?;

        // Show diff statistics with color (use terminal width for proper formatting)
        let term_width = crate::display::get_terminal_width();
        let diff_stat = repo.run_command(&[
            "diff",
            "--color=always",
            "--stat",
            &format!("--stat-width={}", term_width),
            &format!("{}..HEAD", target_branch),
        ])?;

        let diff_stat = diff_stat.trim_end();
        if !diff_stat.is_empty() {
            crate::output::gutter(format_with_gutter(diff_stat, "", None))?;
        }
    }

    // Get git common dir for the push
    let git_common_dir = repo.git_common_dir()?;

    // Perform the push
    let push_target = format!("HEAD:{}", target_branch);
    repo.run_command(&["push", git_common_dir.to_str().unwrap(), &push_target])
        .map_err(|e| GitError::PushFailed {
            error: e.to_string(),
        })?;

    // Show success message after push completes
    if commit_count > 0 {
        // Use the diff statistics captured earlier (before push)
        let mut summary_parts = vec![format!(
            "{} commit{}",
            commit_count,
            if commit_count == 1 { "" } else { "s" }
        )];
        summary_parts.extend(stats_summary);

        crate::output::success(format!(
            "{GREEN}{verb} {GREEN_BOLD}{target_branch}{GREEN_BOLD:#}{GREEN:#} ({})",
            summary_parts.join(", ")
        ))?;
    } else {
        crate::output::success(format!(
            "{GREEN}{verb} {GREEN_BOLD}{target_branch}{GREEN_BOLD:#}{GREEN:#}"
        ))?;
    }

    Ok(())
}
