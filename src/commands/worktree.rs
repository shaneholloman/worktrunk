//! Worktree operations with dual-mode output for shell integration.
//!
//! Note: This module uses message functions from worktrunk::styling.
//!
//! # The Directory Change Problem
//!
//! Worktree commands (`switch`, `remove`, `merge`) need to change the user's working directory,
//! but there's a fundamental Unix limitation: **child processes cannot change their parent's
//! working directory**. This is a security feature and core Unix design principle.
//!
//! When a user runs `wt switch my-feature`, the `wt` binary runs as a child process of the shell.
//! The binary can change *its own* working directory, but when it exits, the parent shell remains
//! in the original directory.
//!
//! # Solution: Dual-Mode Output
//!
//! We solve this with two output modes:
//!
//! ## Without `--internal` (Direct Binary Call)
//!
//! ```bash
//! $ wt switch my-feature
//! Created new branch and worktree for 'my-feature' at /path/to/worktree
//!
//! Run `wt config shell install` to enable automatic cd
//!
//! $ pwd
//! /original/directory  # ← User is still here!
//! ```
//!
//! The binary performs git operations and prints user-friendly messages, but **cannot** change
//! the parent shell's directory. User must manually `cd` to the worktree.
//!
//! ## With `--internal` (Via Shell Wrapper)
//!
//! ```bash
//! $ wt switch my-feature
//! Created new branch and worktree for 'my-feature' at /path/to/worktree
//!
//! $ pwd
//! /path/to/worktree  # ← Automatically changed!
//! ```
//!
//! When shell integration is enabled (`eval "$(wt config shell init bash)"`), the shell function
//! intercepts commands and adds `--internal`:
//!
//! 1. Shell wrapper calls: `wt switch --internal my-feature`
//! 2. Binary streams user-facing messages to **stderr** (real-time feedback)
//! 3. At exit, binary outputs a shell script to **stdout** (e.g., `cd '/path/to/worktree'`)
//! 4. Shell wrapper captures stdout via `$()` and evals it in the parent shell
//!
//! The binary **never changes directories itself** - it just outputs a shell script that the
//! wrapper evals to perform the cd.
//!
//! # Implementation Details
//!
//! Result types (`SwitchResult`, `RemoveResult`) are pure data structures that only contain
//! operation results. All presentation logic is handled by the `output` module:
//!
//! - `output::handle_switch_output()`: Formats and outputs switch operation results
//! - `output::handle_remove_output()`: Formats and outputs remove operation results
//!
//! These handlers automatically select the appropriate mode (user-friendly or directive protocol)
//! based on the `internal` flag.
//!
//! ## Shell Script Protocol
//!
//! In directive mode (`--internal`), the binary:
//! - Streams all user messages to **stderr** (real-time, with colors)
//! - Buffers cd/exec directives internally
//! - At exit, emits a shell script to **stdout**:
//!
//! ```bash
//! cd '/path/to/worktree'
//! echo 'optional follow-up command'
//! ```
//!
//! The shell wrapper captures this via command substitution and evals it:
//!
//! ```bash
//! wt() {
//!     local script exit_code=0
//!     script="$(command "$WORKTRUNK_BIN" --internal "$@" 2>&2)" || exit_code=$?
//!     if [[ -n "$script" ]]; then
//!         eval "$script"
//!     fi
//!     return "$exit_code"
//! }
//! ```
//!
//! This pattern (stderr for logs, stdout for script) is proven by direnv. Benefits:
//! - No FIFOs, no background processes, no job control suppression
//! - Full streaming: stderr goes directly to terminal while wt runs
//! - Simple shell wrapper: just command substitution + eval
//!
//! ## Exit Code Semantics
//!
//! When using `-x` to execute commands after switching:
//!
//! - **If wt operation fails**: Returns wt's exit code (command never executes)
//! - **If wt succeeds but command fails**: Returns the command's exit code
//! - **Rationale**: Enables command chaining with proper error propagation
//!
//! Example:
//! ```bash
//! wt switch feature -x "cargo build" && cargo test
//! # If wt fails (e.g., worktree doesn't exist), cargo build never runs
//! # If cargo build fails, cargo test doesn't run (exit code propagates)
//! ```
//!
//! The shell wrapper is generated by `wt config shell init <shell>` from templates in `templates/`.

use color_print::cformat;
use dunce::canonicalize;
use normalize_path::NormalizePath;
use std::path::PathBuf;
use worktrunk::HookType;
use worktrunk::config::WorktrunkConfig;
use worktrunk::git::{GitError, Repository, ResolvedWorktree};
use worktrunk::styling::{
    format_with_gutter, hint_message, info_message, progress_message, success_message,
    warning_message,
};

use super::command_executor::CommandContext;
use super::hooks::{HookFailureStrategy, HookPipeline, HookSource};
use super::repository_ext::RepositoryCliExt;

/// Resolve a worktree argument using path-first lookup.
///
/// Resolution order:
/// 1. Special symbols ("@", "-", "^") are handled specially
/// 2. Compute expected path for the argument using config template
/// 3. If a worktree exists at that path, return it (regardless of branch)
/// 4. Otherwise, look up by branch name (standard fallback)
///
/// Conflict detection: If expected path has a worktree on branch X, but argument
/// matches branch Y which has a worktree elsewhere, an error is raised.
///
/// This allows `wt remove foo` to target the worktree at `repo.foo/` even if
/// that worktree is on a different branch.
pub fn resolve_worktree_path_first(
    repo: &Repository,
    name: &str,
    config: &WorktrunkConfig,
) -> anyhow::Result<ResolvedWorktree> {
    // Special symbols bypass path-first lookup
    match name {
        "@" => {
            // Current worktree by path - works even in detached HEAD
            let path = repo.worktree_root()?;
            let worktrees = repo.list_worktrees()?;
            let branch = worktrees
                .worktrees
                .iter()
                .find(|wt| wt.path == path)
                .and_then(|wt| wt.branch.clone());
            return Ok(ResolvedWorktree::Worktree { path, branch });
        }
        "-" | "^" => {
            // These resolve to branch names, use standard branch-based lookup
            return repo.resolve_worktree(name);
        }
        _ => {}
    }

    // Compute expected path for this argument
    let expected_path = compute_worktree_path(repo, name, config)?;

    // Check if a worktree exists at the expected path
    if let Some((path, branch_at_path)) = repo.worktree_at_path(&expected_path)? {
        // Worktree exists at expected path - check for ambiguity
        // If the argument also matches a different branch with a worktree elsewhere,
        // that's ambiguous and we should error
        // Note: resolve_worktree_name won't fail with DetachedHead here because "@"
        // was already handled in the early return above
        let branch = repo.resolve_worktree_name(name)?;
        if branch_at_path.as_deref() != Some(&branch) {
            // The worktree at expected path is on a different branch than the argument
            if let Some(other_path) = repo.worktree_for_branch(&branch)? {
                // And the argument matches a branch that has a worktree elsewhere
                // This is ambiguous - error to prevent confusion
                return Err(GitError::WorktreePathMismatch {
                    branch,
                    expected_path,
                    actual_path: other_path,
                }
                .into());
            }
        }
        return Ok(ResolvedWorktree::Worktree {
            path,
            branch: branch_at_path,
        });
    }

    // No worktree at expected path - fall back to branch-based lookup
    // This handles cases like manually-created worktrees at non-standard paths
    let branch = repo.resolve_worktree_name(name)?;
    match repo.worktree_for_branch(&branch)? {
        Some(path) => Ok(ResolvedWorktree::Worktree {
            path,
            branch: Some(branch),
        }),
        None => Ok(ResolvedWorktree::BranchOnly { branch }),
    }
}

/// Compute the expected worktree path for a branch name.
pub fn compute_worktree_path(
    repo: &Repository,
    branch: &str,
    config: &WorktrunkConfig,
) -> anyhow::Result<PathBuf> {
    let repo_root = repo.worktree_base()?;
    let repo_name = repo_root
        .file_name()
        .ok_or_else(|| anyhow::anyhow!("Repository path has no filename: {}", repo_root.display()))?
        .to_str()
        .ok_or_else(|| {
            anyhow::anyhow!(
                "Repository path contains invalid UTF-8: {}",
                repo_root.display()
            )
        })?;

    let relative_path = config
        .format_path(repo_name, branch)
        .map_err(|e| anyhow::anyhow!("Failed to format worktree path: {e}"))?;

    // Normalize to resolve ".." from relative paths like "../repo.branch"
    Ok(repo_root.join(relative_path).normalize())
}

/// Flags indicating which merge operations occurred
#[derive(Debug, Clone, Copy)]
pub struct MergeOperations {
    pub committed: bool,
    pub squashed: bool,
    pub rebased: bool,
}

/// Result of a worktree switch operation
pub enum SwitchResult {
    /// Already at the target worktree (no action taken)
    AlreadyAt(PathBuf),
    /// Switched to existing worktree at the given path
    Existing(PathBuf),
    /// Created new worktree at the given path
    Created {
        path: PathBuf,
        /// True if we used `-b` to create a new branch (--create flag)
        created_branch: bool,
        /// Base branch when creating new branch (e.g., "main")
        base_branch: Option<String>,
        /// Remote tracking branch if created from remote (e.g., "origin/feature")
        /// This is set when git's DWIM created a local branch from a remote
        from_remote: Option<String>,
    },
}

impl SwitchResult {
    /// Get the worktree path
    pub fn path(&self) -> &PathBuf {
        match self {
            SwitchResult::AlreadyAt(path) => path,
            SwitchResult::Existing(path) => path,
            SwitchResult::Created { path, .. } => path,
        }
    }
}

/// Result of a worktree remove operation
pub enum RemoveResult {
    /// Removed worktree and returned to main (if needed)
    RemovedWorktree {
        main_path: PathBuf,
        worktree_path: PathBuf,
        changed_directory: bool,
        /// Branch name, if known. None for detached HEAD state.
        branch_name: Option<String>,
        no_delete_branch: bool,
        force_delete: bool,
        target_branch: Option<String>,
    },
    /// Branch exists but has no worktree - attempt branch deletion only
    BranchOnly {
        branch_name: String,
        no_delete_branch: bool,
        force_delete: bool,
    },
}

pub fn handle_switch(
    branch: &str,
    create: bool,
    base: Option<&str>,
    force: bool,
    no_verify: bool,
    config: &WorktrunkConfig,
) -> anyhow::Result<(SwitchResult, String)> {
    let repo = Repository::current();

    // Get the actual current branch BEFORE switching.
    // This is what we'll record as "previous" in history for `wt switch -` support.
    let actual_current_branch = repo.current_branch().ok().flatten();

    // Resolve special branch names ("@" for current, "-" for previous)
    let resolved_branch = repo.resolve_worktree_name(branch)?;

    // Record actual current branch as new "previous" for ping-pong behavior
    let new_previous = actual_current_branch;

    // Resolve base if provided
    let resolved_base = if let Some(base_str) = base {
        Some(repo.resolve_worktree_name(base_str)?)
    } else {
        None
    };

    // Check for conflicting conditions
    if create && repo.local_branch_exists(&resolved_branch)? {
        return Err(GitError::BranchAlreadyExists {
            branch: resolved_branch.clone(),
        }
        .into());
    }

    // Warn if --create would shadow a remote branch
    if create {
        let remotes = repo.remotes_with_branch(&resolved_branch)?;
        if !remotes.is_empty() {
            let remote_ref = format!("{}/{}", remotes[0], resolved_branch);
            crate::output::print(warning_message(cformat!(
                "Branch <bold>{resolved_branch}</> exists on remote ({remote_ref}); creating new branch from base instead"
            )))?;
            crate::output::print(hint_message(cformat!(
                "Use <bright-black>wt switch {resolved_branch}</> (without <bright-black>--create</>) to switch to the remote branch"
            )))?;
        }
    }

    // Check if base flag was provided without create flag
    if resolved_base.is_some() && !create {
        crate::output::print(warning_message(
            "--base flag is only used with --create, ignoring",
        ))?;
    }

    // Compute expected worktree path for this branch
    let expected_path = compute_worktree_path(&repo, &resolved_branch, config)?;

    // Helper to build switch result for an existing worktree
    let switch_to_existing = |path: PathBuf, branch: String| -> (SwitchResult, String) {
        let canonical_path = canonicalize(&path).unwrap_or(path);
        let current_dir = std::env::current_dir()
            .ok()
            .and_then(|p| canonicalize(&p).ok());
        let already_at_worktree = current_dir
            .as_ref()
            .map(|cur| cur == &canonical_path)
            .unwrap_or(false);

        let result = if already_at_worktree {
            SwitchResult::AlreadyAt(canonical_path)
        } else {
            SwitchResult::Existing(canonical_path)
        };
        (result, branch)
    };

    // Path-first lookup: check if a worktree exists at the expected path
    if let Some((existing_path, path_branch)) = repo.worktree_at_path(&expected_path)? {
        // Check if directory actually exists (git might have stale metadata)
        if !existing_path.exists() {
            let branch = path_branch.unwrap_or_else(|| resolved_branch.clone());
            return Err(GitError::WorktreeMissing { branch }.into());
        }
        // Worktree exists at expected path - switch to it regardless of its branch
        let _ = repo.record_switch_previous(new_previous.as_deref());
        let actual_branch = path_branch.unwrap_or_else(|| resolved_branch.clone());
        return Ok(switch_to_existing(existing_path, actual_branch));
    }

    // Fallback: check if branch has a worktree at a different path
    match repo.worktree_for_branch(&resolved_branch)? {
        Some(existing_path) if existing_path.exists() => {
            let _ = repo.record_switch_previous(new_previous.as_deref());
            return Ok(switch_to_existing(existing_path, resolved_branch));
        }
        Some(_) => {
            return Err(GitError::WorktreeMissing {
                branch: resolved_branch.clone(),
            }
            .into());
        }
        None => {}
    }

    // No existing worktree at expected path or for branch - will create one
    let worktree_path = expected_path;

    // If the target path already exists but is NOT a worktree (e.g., stale directory),
    // surface a helpful error instead of letting git fail with "already exists".
    if worktree_path.exists() {
        return Err(GitError::WorktreePathExists {
            path: worktree_path,
        }
        .into());
    }

    // Create the worktree
    // Build git worktree add command
    let mut args = vec!["worktree", "add", worktree_path.to_str().unwrap()];

    // Use the resolved base, or default to default branch if creating without a base
    let base_for_creation = if create {
        match resolved_base {
            Some(b) => Some(b),
            None => Some(repo.resolve_target_branch(None)?),
        }
    } else {
        None
    };

    // Build args based on whether we're creating or checking out
    if create {
        args.push("-b");
        args.push(&resolved_branch);
        if let Some(ref base_branch) = base_for_creation {
            args.push(base_branch);
        }
    } else {
        args.push(&resolved_branch);
    }

    // Create worktree and parse specific error cases
    if let Err(e) = repo.run_command(&args) {
        let msg = e.to_string();
        // Check if error is about directory already existing
        if msg.contains("already exists") {
            // Parse the path from git's error message
            // Format: "fatal: '/path/to/dir' already exists"
            if let Some(path_str) = msg
                .lines()
                .find(|line| line.contains("already exists"))
                .and_then(|line| {
                    // Extract path between quotes
                    line.split('\'').nth(1).or_else(|| line.split('"').nth(1))
                })
            {
                return Err(GitError::WorktreePathExists {
                    path: std::path::PathBuf::from(path_str),
                }
                .into());
            }
        }
        // Check if error is about invalid reference (branch not found)
        // Format: "fatal: invalid reference: branch-name"
        if msg.contains("invalid reference:") {
            return Err(GitError::InvalidReference {
                reference: resolved_branch.clone(),
            }
            .into());
        }
        // Fall back to generic error with context
        return Err(GitError::WorktreeCreationFailed {
            branch: resolved_branch.clone(),
            base_branch: base_for_creation.clone(),
            error: msg,
        }
        .into());
    }

    // Check if git's DWIM created a tracking branch from a remote
    // This happens when we don't use --create and the branch exists on a remote
    let from_remote = if !create {
        // Query the new worktree for its upstream tracking branch
        let worktree_repo = Repository::at(&worktree_path);
        worktree_repo.upstream_branch(&resolved_branch)?
    } else {
        None
    };

    // Execute post-create commands (sequential, blocking)
    // Note: If user declines, continue anyway - worktree already created
    if !no_verify {
        let repo_root = repo.worktree_base()?;
        let ctx = CommandContext::new(
            &repo,
            config,
            Some(&resolved_branch),
            &worktree_path,
            &repo_root,
            force,
        );
        // Approval was handled at the gate
        ctx.execute_post_create_commands(true)?;
    }

    // Note: post-start commands are spawned AFTER success message is shown
    // (see main.rs switch handler for temporal locality)

    // Record successful switch in history for `wt switch -` support
    let _ = repo.record_switch_previous(new_previous.as_deref());

    Ok((
        SwitchResult::Created {
            path: worktree_path,
            created_branch: create,
            base_branch: base_for_creation,
            from_remote,
        },
        resolved_branch,
    ))
}

pub fn handle_remove(
    worktree_name: &str,
    no_delete_branch: bool,
    force_delete: bool,
    background: bool,
) -> anyhow::Result<RemoveResult> {
    let repo = Repository::current();

    // Show progress (unless running in background - output handler will show command)
    if !background {
        crate::output::print(progress_message(cformat!(
            "Removing worktree for <bold>{worktree_name}</>..."
        )))?;
    }

    repo.remove_worktree_by_name(worktree_name, no_delete_branch, force_delete)
}

/// Handle removing the current worktree (supports detached HEAD state).
///
/// This is the path-based removal that handles the "@" shorthand, including
/// when HEAD is detached.
pub fn handle_remove_current(
    no_delete_branch: bool,
    force_delete: bool,
    background: bool,
) -> anyhow::Result<RemoveResult> {
    let repo = Repository::current();

    // Show progress (unless running in background - output handler will show command)
    if !background {
        crate::output::print(progress_message("Removing current worktree..."))?;
    }

    repo.remove_current_worktree(no_delete_branch, force_delete)
}

/// Handle removing a worktree by path (for detached non-current worktrees).
///
/// This is used when a worktree is in detached HEAD state and we're not
/// currently in it. We can still remove the worktree, we just don't know
/// which branch (if any) to delete.
pub fn handle_remove_by_path(
    path: &std::path::Path,
    branch: Option<String>,
    force_delete: bool,
    background: bool,
) -> anyhow::Result<RemoveResult> {
    let repo = Repository::current();

    if !background {
        crate::output::print(progress_message(cformat!(
            "Removing worktree at <bold>{}</>...",
            worktrunk::path::format_path_for_display(path)
        )))?;
    }

    // Check that the worktree is clean
    let target_repo = Repository::at(path);
    target_repo.ensure_clean_working_tree(Some("remove worktree"), branch.as_deref())?;

    // We're not in this worktree, so no directory change needed
    let current_path = repo.worktree_root()?;

    Ok(RemoveResult::RemovedWorktree {
        main_path: current_path,
        worktree_path: path.to_path_buf(),
        changed_directory: false,
        branch_name: branch,
        no_delete_branch: true, // Can't delete branch for detached worktree
        force_delete,
        target_branch: None,
    })
}

impl<'a> CommandContext<'a> {
    /// Execute post-create commands sequentially (blocking)
    ///
    /// Runs user hooks first, then project hooks. Skips all hooks if verify is false.
    pub fn execute_post_create_commands(&self, verify: bool) -> anyhow::Result<()> {
        if !verify {
            return Ok(());
        }

        let pipeline = HookPipeline::new(*self);

        // Run user hooks first (no approval required)
        if let Some(user_config) = &self.config.post_create {
            pipeline.run_sequential(
                user_config,
                HookType::PostCreate,
                HookSource::User,
                &[],
                HookFailureStrategy::Warn,
                None,
            )?;
        }

        // Then run project hooks (approval checked at gate, not here)
        let project_config = match self.repo.load_project_config()? {
            Some(cfg) => cfg,
            None => return Ok(()),
        };

        let Some(post_create_config) = &project_config.post_create else {
            return Ok(());
        };

        pipeline.run_sequential(
            post_create_config,
            HookType::PostCreate,
            HookSource::Project,
            &[],
            HookFailureStrategy::Warn,
            None,
        )?;
        Ok(())
    }

    /// Spawn post-start commands in parallel as background processes (non-blocking)
    ///
    /// Spawns user hooks first, then project hooks. Skips all hooks if verify is false.
    pub fn spawn_post_start_commands(&self, verify: bool) -> anyhow::Result<()> {
        if !verify {
            return Ok(());
        }

        let pipeline = HookPipeline::new(*self);

        // Spawn user hooks first (no approval required)
        if let Some(user_config) = &self.config.post_start {
            pipeline.spawn_background(
                user_config,
                HookType::PostStart,
                HookSource::User,
                &[],
                None,
            )?;
        }

        // Then spawn project hooks (approval checked at gate, not here)
        let project_config = match self.repo.load_project_config()? {
            Some(cfg) => cfg,
            None => return Ok(()),
        };

        let Some(post_start_config) = &project_config.post_start else {
            return Ok(());
        };

        pipeline.spawn_background(
            post_start_config,
            HookType::PostStart,
            HookSource::Project,
            &[],
            None,
        )
    }
}

/// Push changes to target branch
///
/// The `operations` parameter indicates which merge operations occurred (commit, squash, rebase).
/// Pass `None` for standalone push operations where these concepts don't apply.
///
/// During the push stage we temporarily `git stash` non-overlapping changes in the
/// target worktree (if present) so that concurrent edits there do not block the
/// fast-forward. The stash is restored afterward and we bail out early if any file
/// overlaps with the push range.
pub fn handle_push(
    target: Option<&str>,
    allow_merge_commits: bool,
    verb: &str,
    operations: Option<MergeOperations>,
) -> anyhow::Result<()> {
    let repo = Repository::current();

    // Get target branch (default to default branch if not provided)
    let target_branch = repo.resolve_target_branch(target)?;

    // A worktree for the target branch is optional for push:
    // - If present, we use it to check for overlapping dirty files.
    // - If absent, we skip that safety step but still allow the push (git itself is fine).
    let target_worktree_path = repo.worktree_for_branch(&target_branch)?;

    // Check if it's a fast-forward
    if !repo.is_ancestor(&target_branch, "HEAD")? {
        // Get formatted commit log (commits in target that we don't have)
        let commits_formatted = repo
            .run_command(&[
                "log",
                "--color=always",
                "--graph",
                "--oneline",
                &format!("HEAD..{}", target_branch),
            ])?
            .trim()
            .to_string();

        return Err(GitError::NotFastForward {
            target_branch: target_branch.clone(),
            commits_formatted,
            in_merge_context: operations.is_some(),
        }
        .into());
    }

    // Check for merge commits unless allowed
    let has_merge_commits = repo.has_merge_commits(&target_branch, "HEAD")?;
    if !allow_merge_commits && has_merge_commits {
        return Err(GitError::MergeCommitsFound.into());
    }

    // Check for conflicting changes in target worktree (auto-stash safe changes)
    let mut target_worktree_stash =
        repo.prepare_target_worktree(target_worktree_path.as_ref(), &target_branch)?;

    // Count commits and show what will be pushed
    let commit_count = repo.count_commits(&target_branch, "HEAD")?;

    // Get diff statistics BEFORE push (will be needed for success message later)
    let stats_summary = if commit_count > 0 {
        repo.diff_stats_summary(&["diff", "--shortstat", &format!("{}..HEAD", target_branch)])
    } else {
        Vec::new()
    };

    // Build and show consolidated message with squash/rebase info
    if commit_count > 0 {
        let commit_text = if commit_count == 1 {
            "commit"
        } else {
            "commits"
        };
        let head_sha = repo.run_command(&["rev-parse", "--short", "HEAD"])?;
        let head_sha = head_sha.trim();

        let verb_ing = if verb.starts_with("Merged") {
            "Merging"
        } else {
            "Pushing"
        };

        // Build parenthetical showing which operations didn't happen and flags used
        let mut notes = Vec::new();

        // Skipped operations - only include if we're in merge workflow context
        if let Some(ops) = operations {
            let mut skipped_ops = Vec::new();
            if !ops.committed && !ops.squashed {
                // Neither commit nor squash happened - combine them
                skipped_ops.push("commit/squash");
            }
            if !ops.rebased {
                skipped_ops.push("rebase");
            }
            if !skipped_ops.is_empty() {
                notes.push(format!("no {} needed", skipped_ops.join("/")));
            }
        }

        // Flag acknowledgments
        if allow_merge_commits && has_merge_commits {
            notes.push("merge commits allowed".to_string());
        }

        let operations_note = if notes.is_empty() {
            String::new()
        } else {
            format!(" ({})", notes.join(", "))
        };

        crate::output::print(progress_message(cformat!(
            "{verb_ing} {commit_count} {commit_text} to <bold>{target_branch}</> @ <dim>{head_sha}</>{operations_note}"
        )))?;

        // Show the commit graph with color
        let log_output = repo.run_command(&[
            "log",
            "--color=always",
            "--graph",
            "--oneline",
            &format!("{}..HEAD", target_branch),
        ])?;
        crate::output::gutter(format_with_gutter(&log_output, "", None))?;

        // Show diff statistics
        super::show_diffstat(&repo, &format!("{}..HEAD", target_branch))?;
    }

    // Get git common dir for the push
    let git_common_dir = repo.git_common_dir()?;

    // Perform the push
    // Use --receive-pack to pass config to the receiving end without permanently mutating repo config
    let push_target = format!("HEAD:{}", target_branch);
    if let Err(e) = repo.run_command(&[
        "push",
        "--receive-pack=git -c receive.denyCurrentBranch=updateInstead receive-pack",
        git_common_dir.to_str().unwrap(),
        &push_target,
    ]) {
        if let Some(stash) = target_worktree_stash.take() {
            stash.restore()?;
        }
        // CommandFailed contains raw git output, wrap in PushFailed for proper formatting
        return Err(GitError::PushFailed {
            error: e.to_string(),
        }
        .into());
    }

    if let Some(stash) = target_worktree_stash.take() {
        stash.restore()?;
    }

    // Show success message after push completes
    if commit_count > 0 {
        // Use the diff statistics captured earlier (before push)
        let mut summary_parts = vec![format!(
            "{} commit{}",
            commit_count,
            if commit_count == 1 { "" } else { "s" }
        )];
        summary_parts.extend(stats_summary);

        // Re-apply bright-black after stats (which end with a reset) so ) is also gray
        let stats_str = summary_parts.join(", ");
        let paren_close = cformat!("<bright-black>)</>"); // Separate to avoid cformat optimization
        crate::output::print(success_message(cformat!(
            "{verb} <bold>{target_branch}</> <bright-black>({stats_str}</>{}",
            paren_close
        )))?;
    } else {
        // For merge workflow context, explain why nothing was pushed
        let context = if let Some(ops) = operations {
            let mut notes = Vec::new();
            if !ops.committed && !ops.squashed {
                notes.push("no new commits");
            }
            if !ops.rebased {
                notes.push("no rebase needed");
            }
            if notes.is_empty() {
                String::new()
            } else {
                format!(" ({})", notes.join(", "))
            }
        } else {
            String::new()
        };

        // No action: nothing was pushed, just acknowledging state
        crate::output::print(info_message(cformat!(
            "Already up to date with <bold>{target_branch}</>{context}"
        )))?;
    }

    Ok(())
}
