//! Worktree operations with dual-mode output for shell integration.
//!
//! # The Directory Change Problem
//!
//! Worktree commands (`switch`, `remove`, `merge`) need to change the user's working directory,
//! but there's a fundamental Unix limitation: **child processes cannot change their parent's
//! working directory**. This is a security feature and core Unix design principle.
//!
//! When a user runs `wt switch my-feature`, the `wt` binary runs as a child process of the shell.
//! The binary can change *its own* working directory, but when it exits, the parent shell remains
//! in the original directory.
//!
//! # Solution: Dual-Mode Output
//!
//! We solve this with two output modes:
//!
//! ## Without `--internal` (Direct Binary Call)
//!
//! ```bash
//! $ wt switch my-feature
//! Created new branch and worktree for 'my-feature' at /path/to/worktree
//!
//! To enable automatic cd, run: wt configure-shell
//!
//! $ pwd
//! /original/directory  # ‚Üê User is still here!
//! ```
//!
//! The binary performs git operations and prints user-friendly messages, but **cannot** change
//! the parent shell's directory. User must manually `cd` to the worktree.
//!
//! ## With `--internal` (Via Shell Wrapper)
//!
//! ```bash
//! $ wt switch my-feature
//! Created new branch and worktree for 'my-feature' at /path/to/worktree
//!
//! $ pwd
//! /path/to/worktree  # ‚Üê Automatically changed!
//! ```
//!
//! When shell integration is enabled (`eval "$(wt init bash)"`), the shell function intercepts
//! commands and adds `--internal`:
//!
//! 1. Shell wrapper calls: `wt switch --internal my-feature`
//! 2. Binary outputs special directive protocol:
//!    ```
//!    __WORKTRUNK_CD__/path/to/worktree
//!    Created new branch and worktree for 'my-feature' at /path/to/worktree
//!    ```
//! 3. Shell wrapper parses output line-by-line
//! 4. When it sees `__WORKTRUNK_CD__<path>`, it executes `cd <path>` in the parent shell
//! 5. Other lines are printed normally
//!
//! The binary **never changes directories itself** - it just communicates the desired path back
//! to the shell wrapper via stdout using the `__WORKTRUNK_CD__` directive protocol.
//!
//! # Implementation Details
//!
//! Result types (`SwitchResult`, `RemoveResult`) are pure data structures that only contain
//! operation results. All presentation logic is handled by the `output` module:
//!
//! - `output::handle_switch_output()`: Formats and outputs switch operation results
//! - `output::handle_remove_output()`: Formats and outputs remove operation results
//!
//! These handlers automatically select the appropriate mode (user-friendly or directive protocol)
//! based on the `internal` flag
//!
//! ## Directive Protocol
//!
//! Directives are NUL-terminated to support multi-line commands (e.g., via `-x` flag):
//!
//! ```text
//! __WORKTRUNK_CD__/path/to/worktree\0
//! Message for user\0
//! __WORKTRUNK_EXEC__echo 'line1'\necho 'line2'\0
//! ```
//!
//! Shell wrappers split on `\0` bytes and process each chunk:
//! - `__WORKTRUNK_CD__<path>`: Change directory to `<path>`
//! - `__WORKTRUNK_EXEC__<command>`: Execute `<command>` (may contain newlines)
//! - Other chunks: Print as regular output
//!
//! ## Exit Code Semantics
//!
//! When using `-x` to execute commands after switching:
//!
//! - **Exit code returned**: The `wt` command's exit code
//! - **Command execution**: Runs for side effects; failures are logged but don't affect exit code
//! - **Rationale**: Allows scripts to detect `wt` failures (e.g., branch already exists) while
//!   still executing post-switch commands for convenience
//!
//! Example:
//! ```bash
//! wt switch --create feature -x "editor ."  # Opens editor even if branch exists
//! echo $?  # Returns wt's exit code, not editor's
//! ```
//!
//! The shell wrapper is generated by `wt init <shell>` from templates in `templates/`.
//!
//! See also: DEMO.md for detailed architecture explanation.

use std::path::PathBuf;
use worktrunk::config::{ProjectConfig, WorktrunkConfig};
use worktrunk::git::{GitError, Repository};
use worktrunk::styling::{
    ADDITION, AnstyleStyle, CYAN, CYAN_BOLD, DELETION, GREEN, GREEN_BOLD, SUCCESS_EMOJI, WARNING,
    WARNING_EMOJI, eprint, format_with_gutter, println,
};

use super::command_executor::{CommandContext, prepare_project_commands};
use crate::commands::process::spawn_detached;
use crate::output::execute_command_in_worktree;

/// Result of a worktree switch operation
pub enum SwitchResult {
    /// Switched to existing worktree at the given path
    ExistingWorktree(PathBuf),
    /// Created new worktree at the given path
    CreatedWorktree { path: PathBuf, created_branch: bool },
}

impl SwitchResult {
    /// Get the worktree path
    pub fn path(&self) -> &PathBuf {
        match self {
            SwitchResult::ExistingWorktree(path) => path,
            SwitchResult::CreatedWorktree { path, .. } => path,
        }
    }
}

/// Result of a worktree remove operation
pub enum RemoveResult {
    /// Already on default branch, no action taken
    AlreadyOnDefault(String),
    /// Removed worktree and returned to primary
    RemovedWorktree { primary_path: PathBuf },
    /// Switched to default branch in main repo
    SwitchedToDefault(String),
    /// Removed a different worktree (not the current one)
    RemovedOtherWorktree { branch: String },
}

pub fn handle_switch(
    branch: &str,
    create: bool,
    base: Option<&str>,
    force: bool,
    no_hooks: bool,
    config: &WorktrunkConfig,
) -> Result<SwitchResult, GitError> {
    let repo = Repository::current();

    // Check for conflicting conditions
    if create && repo.branch_exists(branch)? {
        return Err(GitError::BranchAlreadyExists {
            branch: branch.to_string(),
        });
    }

    // Check if base flag was provided without create flag
    if base.is_some() && !create {
        println!(
            "{WARNING_EMOJI} {WARNING}--base flag is only used with --create, ignoring{WARNING:#}"
        );
    }

    // Check if worktree already exists for this branch
    match repo.worktree_for_branch(branch)? {
        Some(existing_path) if existing_path.exists() => {
            // Canonicalize the path for cleaner display
            let canonical_existing_path = existing_path.canonicalize().unwrap_or(existing_path);
            return Ok(SwitchResult::ExistingWorktree(canonical_existing_path));
        }
        Some(_) => {
            return Err(GitError::WorktreeMissing {
                branch: branch.to_string(),
            });
        }
        None => {}
    }

    // No existing worktree, create one
    let repo_root = repo.main_worktree_root()?;

    let repo_name = repo_root
        .file_name()
        .ok_or_else(|| GitError::CommandFailed("Invalid repository path".to_string()))?
        .to_str()
        .ok_or_else(|| GitError::CommandFailed("Invalid UTF-8 in path".to_string()))?;

    let worktree_path = repo_root.join(config.format_path(repo_name, branch));

    // Create the worktree
    // Build git worktree add command
    let mut args = vec!["worktree", "add", worktree_path.to_str().unwrap()];
    if create {
        args.push("-b");
        args.push(branch);
        if let Some(base_branch) = base {
            args.push(base_branch);
        }
    } else {
        args.push(branch);
    }

    repo.run_command(&args)
        .map_err(|e| GitError::CommandFailed(format!("Failed to create worktree: {}", e)))?;

    // Canonicalize the path to resolve any .. components
    let worktree_path = worktree_path.canonicalize().map_err(|e| {
        GitError::CommandFailed(format!("Failed to canonicalize worktree path: {}", e))
    })?;

    // Execute post-create commands (sequential, blocking)
    if !no_hooks {
        execute_post_create_commands(&worktree_path, &repo, config, branch, force)?;
    }

    // Spawn post-start commands (parallel, background)
    if !no_hooks {
        spawn_post_start_commands(&worktree_path, &repo, config, branch, force)?;
    }

    Ok(SwitchResult::CreatedWorktree {
        path: worktree_path,
        created_branch: create,
    })
}

pub fn handle_remove(worktree_name: Option<&str>) -> Result<RemoveResult, GitError> {
    let repo = Repository::current();

    // Two modes: remove current worktree vs. remove by name
    match worktree_name {
        None => remove_current_worktree(&repo),
        Some(name) => remove_worktree_by_name(&repo, name),
    }
}

/// Remove the current worktree (original behavior)
fn remove_current_worktree(repo: &Repository) -> Result<RemoveResult, GitError> {
    // Check for uncommitted changes in current worktree
    repo.ensure_clean_working_tree()?;

    // Get current state
    let current_branch = repo.current_branch()?;
    let default_branch = repo.default_branch()?;
    let in_worktree = repo.is_in_worktree()?;

    // If we're on default branch and not in a worktree, nothing to do
    if !in_worktree && current_branch.as_deref() == Some(&default_branch) {
        return Ok(RemoveResult::AlreadyOnDefault(default_branch));
    }

    if in_worktree {
        // In worktree: navigate to primary worktree and remove this one
        let worktree_root = repo.worktree_root()?;
        let primary_worktree_dir = repo.main_worktree_root()?;

        // Remove the worktree
        if let Err(e) = repo.remove_worktree(&worktree_root) {
            println!("{WARNING_EMOJI} {WARNING}Failed to remove worktree: {e}{WARNING:#}");
            println!(
                "You may need to run 'git worktree remove {}' manually",
                worktree_root.display()
            );
        }

        Ok(RemoveResult::RemovedWorktree {
            primary_path: primary_worktree_dir,
        })
    } else {
        // In main repo but not on default branch: switch to default
        repo.run_command(&["switch", &default_branch])
            .map_err(|e| {
                GitError::CommandFailed(format!("Failed to switch to '{}': {}", default_branch, e))
            })?;

        Ok(RemoveResult::SwitchedToDefault(default_branch))
    }
}

/// Remove a worktree by branch name
fn remove_worktree_by_name(repo: &Repository, branch_name: &str) -> Result<RemoveResult, GitError> {
    // Find the worktree for this branch
    let worktree_path = repo.worktree_for_branch(branch_name)?;

    let worktree_path = match worktree_path {
        Some(path) => path,
        None => {
            return Err(GitError::NoWorktreeFound {
                branch: branch_name.to_string(),
            });
        }
    };

    // Check if the target worktree exists on disk
    if !worktree_path.exists() {
        return Err(GitError::WorktreeMissing {
            branch: branch_name.to_string(),
        });
    }

    // Check if the target worktree is clean (no uncommitted changes)
    let target_repo = Repository::at(&worktree_path);
    target_repo.ensure_clean_working_tree()?;

    // Get the current worktree root to check if we're removing ourselves
    let current_worktree = repo.worktree_root()?;
    let removing_current = current_worktree == worktree_path;

    // Get primary worktree path BEFORE removing (while we can still run git commands)
    let primary_worktree_dir = if removing_current {
        Some(repo.main_worktree_root()?)
    } else {
        None
    };

    // Remove the worktree
    if let Err(e) = repo.remove_worktree(&worktree_path) {
        println!("{WARNING_EMOJI} {WARNING}Failed to remove worktree: {e}{WARNING:#}");
        println!(
            "You may need to run 'git worktree remove {}' manually",
            worktree_path.display()
        );
    }

    // If we removed the current worktree, return to primary
    if let Some(primary_path) = primary_worktree_dir {
        Ok(RemoveResult::RemovedWorktree { primary_path })
    } else {
        // Stay where we are (no directory change needed)
        Ok(RemoveResult::RemovedOtherWorktree {
            branch: branch_name.to_string(),
        })
    }
}

/// Check for conflicting uncommitted changes in target worktree
fn check_worktree_conflicts(
    repo: &Repository,
    target_worktree: &Option<std::path::PathBuf>,
    target_branch: &str,
) -> Result<(), GitError> {
    let Some(wt_path) = target_worktree else {
        return Ok(());
    };

    let wt_repo = Repository::at(wt_path);
    if !wt_repo.is_dirty()? {
        return Ok(());
    }

    // Get files changed in the push
    let push_files = repo.changed_files(target_branch, "HEAD")?;

    // Get files changed in the worktree
    let wt_status_output = wt_repo.run_command(&["status", "--porcelain"])?;

    let wt_files: Vec<String> = wt_status_output
        .lines()
        .filter_map(|line| {
            // Parse porcelain format: "XY filename"
            line.split_once(' ')
                .map(|(_, filename)| filename.trim().to_string())
        })
        .collect();

    // Find overlapping files
    let overlapping: Vec<String> = push_files
        .iter()
        .filter(|f| wt_files.contains(f))
        .cloned()
        .collect();

    if !overlapping.is_empty() {
        return Err(GitError::ConflictingChanges {
            files: overlapping,
            worktree_path: wt_path.to_path_buf(),
        });
    }

    Ok(())
}

/// Helper to load project config with error handling
fn load_project_config(repo: &Repository) -> Result<Option<ProjectConfig>, GitError> {
    let repo_root = repo.worktree_root()?;
    ProjectConfig::load(&repo_root)
        .map_err(|e| GitError::CommandFailed(format!("Failed to load project config: {}", e)))
}

/// Execute post-create commands sequentially (blocking)
fn execute_post_create_commands(
    worktree_path: &std::path::Path,
    repo: &Repository,
    config: &WorktrunkConfig,
    branch: &str,
    force: bool,
) -> Result<(), GitError> {
    let project_config = match load_project_config(repo)? {
        Some(cfg) => cfg,
        None => return Ok(()),
    };

    let Some(post_create_config) = &project_config.post_create_command else {
        return Ok(());
    };

    let ctx = CommandContext::new(repo, config, branch, worktree_path, force);
    let commands = prepare_project_commands(
        post_create_config,
        "cmd",
        &ctx,
        false,
        &[],
        "Post-create commands",
        |_, command| {
            let dim = AnstyleStyle::new().dimmed();
            println!("{dim}Skipping command: {command}{dim:#}");
        },
    )?;

    if commands.is_empty() {
        return Ok(());
    }

    // Execute each command sequentially
    for prepared in commands {
        use std::io::Write;
        println!("üîÑ {CYAN}Executing (post-create):{CYAN:#}");
        eprint!("{}", format_with_gutter(&prepared.expanded, "", None)); // Gutter at column 0
        let _ = std::io::stderr().flush();

        if let Err(e) = execute_command_in_worktree(worktree_path, &prepared.expanded) {
            let warning_bold = WARNING.bold();
            println!(
                "{WARNING_EMOJI} {WARNING}Command {warning_bold}{name}{warning_bold:#} failed: {e}{WARNING:#}",
                name = prepared.name,
            );
            // Continue with other commands even if one fails
        }
    }

    use std::io::Write;
    let _ = std::io::stdout().flush();
    let _ = std::io::stderr().flush();

    Ok(())
}

/// Spawn post-start commands in parallel as background processes (non-blocking)
fn spawn_post_start_commands(
    worktree_path: &std::path::Path,
    repo: &Repository,
    config: &WorktrunkConfig,
    branch: &str,
    force: bool,
) -> Result<(), GitError> {
    let project_config = match load_project_config(repo)? {
        Some(cfg) => cfg,
        None => return Ok(()),
    };

    let Some(post_start_config) = &project_config.post_start_command else {
        return Ok(());
    };

    let ctx = CommandContext::new(repo, config, branch, worktree_path, force);
    let commands = prepare_project_commands(
        post_start_config,
        "cmd",
        &ctx,
        false,
        &[],
        "Post-start commands",
        |_, command| {
            let dim = AnstyleStyle::new().dimmed();
            println!("{dim}Skipping command: {command}{dim:#}");
        },
    )?;

    if commands.is_empty() {
        return Ok(());
    }

    // Spawn each command as a detached background process
    for prepared in commands {
        use std::io::Write;
        println!("üîÑ {CYAN}Starting (background):{CYAN:#}");
        eprint!("{}", format_with_gutter(&prepared.expanded, "", None));
        let _ = std::io::stderr().flush();

        match spawn_detached(worktree_path, &prepared.expanded, &prepared.name) {
            Ok(_log_path) => {
                // Background command spawned successfully
                // Log file path not shown - only needed for debugging failures
            }
            Err(e) => {
                println!(
                    "{WARNING_EMOJI} {WARNING}Failed to spawn '{name}': {e}{WARNING:#}",
                    name = prepared.name,
                );
            }
        }
    }

    use std::io::Write;
    let _ = std::io::stdout().flush();
    let _ = std::io::stderr().flush();

    Ok(())
}

pub fn handle_push(target: Option<&str>, allow_merge_commits: bool) -> Result<(), GitError> {
    let repo = Repository::current();

    // Get target branch (default to default branch if not provided)
    let target_branch = target.map_or_else(|| repo.default_branch(), |b| Ok(b.to_string()))?;

    // Check if it's a fast-forward
    if !repo.is_ancestor(&target_branch, "HEAD")? {
        return Err(GitError::NotFastForward {
            target_branch: target_branch.to_string(),
        });
    }

    // Check for merge commits unless allowed
    if !allow_merge_commits && repo.has_merge_commits(&target_branch, "HEAD")? {
        return Err(GitError::MergeCommitsFound);
    }

    // Configure receive.denyCurrentBranch if needed
    let current_config = repo.get_config("receive.denyCurrentBranch")?;
    if current_config.as_deref() != Some("updateInstead") {
        repo.set_config("receive.denyCurrentBranch", "updateInstead")?;
    }

    // Check for conflicting changes in target worktree
    let target_worktree = repo.worktree_for_branch(&target_branch)?;
    check_worktree_conflicts(&repo, &target_worktree, &target_branch)?;

    // Count commits and show what will be pushed
    let commit_count = repo.count_commits(&target_branch, "HEAD")?;

    // Get diff statistics early so we can use them in the summary
    let diff_shortstat = if commit_count > 0 {
        repo.run_command(&["diff", "--shortstat", &format!("{}..HEAD", target_branch)])?
    } else {
        String::new()
    };

    if commit_count > 0 {
        let commit_text = if commit_count == 1 {
            "commit"
        } else {
            "commits"
        };
        let head_sha = repo.run_command(&["rev-parse", "--short", "HEAD"])?;
        let head_sha = head_sha.trim();

        crate::output::progress(format!(
            "üîÑ {CYAN}Pushing {commit_count} {commit_text} to {CYAN_BOLD}{target_branch}{CYAN_BOLD:#} @ {head_sha}{CYAN:#}\n"
        ))
        .map_err(|e| GitError::CommandFailed(e.to_string()))?;

        // Show the commit graph with color
        let log_output = repo.run_command(&[
            "log",
            "--color=always",
            "--graph",
            "--oneline",
            "--decorate",
            &format!("{}..HEAD", target_branch),
        ])?;
        crate::output::progress(format!("{}\n", log_output.trim()))
            .map_err(|e| GitError::CommandFailed(e.to_string()))?;

        // Show diff statistics with color
        let diff_stat = repo.run_command(&[
            "diff",
            "--color=always",
            "--stat",
            &format!("{}..HEAD", target_branch),
        ])?;

        let diff_stat = diff_stat.trim_end();
        if !diff_stat.is_empty() {
            crate::output::progress(format!("{}\n", diff_stat))
                .map_err(|e| GitError::CommandFailed(e.to_string()))?;
        }
    }

    // Get git common dir for the push
    let git_common_dir = repo.git_common_dir()?;

    // Perform the push
    let push_target = format!("HEAD:{}", target_branch);
    repo.run_command(&["push", git_common_dir.to_str().unwrap(), &push_target])
        .map_err(|e| GitError::PushFailed {
            error: e.to_string(),
        })?;

    // Build success message with statistics
    if commit_count > 0 {
        // Parse shortstat to extract files/insertions/deletions
        // Example: " 3 files changed, 45 insertions(+), 12 deletions(-)"
        let stats = parse_diff_shortstat(&diff_shortstat);

        let mut summary_parts = vec![format!(
            "{} commit{}",
            commit_count,
            if commit_count == 1 { "" } else { "s" }
        )];

        if let Some(files) = stats.files {
            summary_parts.push(format!(
                "{} file{}",
                files,
                if files == 1 { "" } else { "s" }
            ));
        }
        if let Some(insertions) = stats.insertions {
            summary_parts.push(format!("{ADDITION}+{insertions}{ADDITION:#}"));
        }
        if let Some(deletions) = stats.deletions {
            summary_parts.push(format!("{DELETION}-{deletions}{DELETION:#}"));
        }

        crate::output::progress(format!(
            "{SUCCESS_EMOJI} {GREEN}Pushed to {GREEN_BOLD}{target_branch}{GREEN_BOLD:#} ({})  {GREEN:#}",
            summary_parts.join(", ")
        ))
        .map_err(|e| GitError::CommandFailed(e.to_string()))?;
    } else {
        crate::output::progress(format!(
            "{SUCCESS_EMOJI} {GREEN}Pushed to {GREEN_BOLD}{target_branch}{GREEN_BOLD:#}{GREEN:#}"
        ))
        .map_err(|e| GitError::CommandFailed(e.to_string()))?;
    }

    Ok(())
}

/// Parse git diff --shortstat output
struct DiffStats {
    files: Option<usize>,
    insertions: Option<usize>,
    deletions: Option<usize>,
}

fn parse_diff_shortstat(output: &str) -> DiffStats {
    let mut stats = DiffStats {
        files: None,
        insertions: None,
        deletions: None,
    };

    // Example: " 3 files changed, 45 insertions(+), 12 deletions(-)"
    let parts: Vec<&str> = output.split(',').collect();

    for part in parts {
        let part = part.trim();

        if part.contains("file") {
            if let Some(num_str) = part.split_whitespace().next() {
                stats.files = num_str.parse().ok();
            }
        } else if part.contains("insertion") {
            if let Some(num_str) = part.split_whitespace().next() {
                stats.insertions = num_str.parse().ok();
            }
        } else if part.contains("deletion")
            && let Some(num_str) = part.split_whitespace().next()
        {
            stats.deletions = num_str.parse().ok();
        }
    }

    stats
}
