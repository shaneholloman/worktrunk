//! Worktree operations with dual-mode output for shell integration.
//!
//! # The Directory Change Problem
//!
//! Worktree commands (`switch`, `remove`, `merge`) need to change the user's working directory,
//! but there's a fundamental Unix limitation: **child processes cannot change their parent's
//! working directory**. This is a security feature and core Unix design principle.
//!
//! When a user runs `wt switch my-feature`, the `wt` binary runs as a child process of the shell.
//! The binary can change *its own* working directory, but when it exits, the parent shell remains
//! in the original directory.
//!
//! # Solution: Dual-Mode Output
//!
//! We solve this with two output modes:
//!
//! ## Without `--internal` (Direct Binary Call)
//!
//! ```bash
//! $ wt switch my-feature
//! Created new branch and worktree for 'my-feature' at /path/to/worktree
//!
//! To enable automatic cd, run: wt config shell
//!
//! $ pwd
//! /original/directory  # ← User is still here!
//! ```
//!
//! The binary performs git operations and prints user-friendly messages, but **cannot** change
//! the parent shell's directory. User must manually `cd` to the worktree.
//!
//! ## With `--internal` (Via Shell Wrapper)
//!
//! ```bash
//! $ wt switch my-feature
//! Created new branch and worktree for 'my-feature' at /path/to/worktree
//!
//! $ pwd
//! /path/to/worktree  # ← Automatically changed!
//! ```
//!
//! When shell integration is enabled (`eval "$(wt init bash)"`), the shell function intercepts
//! commands and adds `--internal`:
//!
//! 1. Shell wrapper calls: `wt switch --internal my-feature`
//! 2. Binary outputs special directive protocol:
//!    ```text
//!    __WORKTRUNK_CD__/path/to/worktree
//!    Created new branch and worktree for 'my-feature' at /path/to/worktree
//!    ```
//! 3. Shell wrapper parses output line-by-line
//! 4. When it sees `__WORKTRUNK_CD__<path>`, it executes `cd <path>` in the parent shell
//! 5. Other lines are printed normally
//!
//! The binary **never changes directories itself** - it just communicates the desired path back
//! to the shell wrapper via stdout using the `__WORKTRUNK_CD__` directive protocol.
//!
//! # Implementation Details
//!
//! Result types (`SwitchResult`, `RemoveResult`) are pure data structures that only contain
//! operation results. All presentation logic is handled by the `output` module:
//!
//! - `output::handle_switch_output()`: Formats and outputs switch operation results
//! - `output::handle_remove_output()`: Formats and outputs remove operation results
//!
//! These handlers automatically select the appropriate mode (user-friendly or directive protocol)
//! based on the `internal` flag
//!
//! ## Directive Protocol
//!
//! Directives are NUL-terminated to support multi-line commands (e.g., via `-x` flag):
//!
//! ```text
//! __WORKTRUNK_CD__/path/to/worktree\0
//! Message for user\0
//! __WORKTRUNK_EXEC__echo 'line1'\necho 'line2'\0
//! ```
//!
//! Shell wrappers split on `\0` bytes and process each chunk:
//! - `__WORKTRUNK_CD__<path>`: Change directory to `<path>`
//! - `__WORKTRUNK_EXEC__<command>`: Execute `<command>` (may contain newlines)
//! - Other chunks: Print as regular output
//!
//! ## Exit Code Semantics
//!
//! When using `-x` to execute commands after switching:
//!
//! - **Exit code returned**: The `wt` command's exit code
//! - **Command execution**: Runs for side effects; failures are logged but don't affect exit code
//! - **Rationale**: Allows scripts to detect `wt` failures (e.g., branch already exists) while
//!   still executing post-switch commands for convenience
//!
//! Example:
//! ```bash
//! wt switch --create feature -x "editor ."  # Opens editor even if branch exists
//! echo $?  # Returns wt's exit code, not editor's
//! ```
//!
//! The shell wrapper is generated by `wt init <shell>` from templates in `templates/`.

use std::path::PathBuf;
use std::time::{SystemTime, UNIX_EPOCH};
use worktrunk::config::{CommandPhase, WorktrunkConfig};
use worktrunk::git::{GitError, GitResultExt, Repository};
use worktrunk::styling::{
    CYAN, CYAN_BOLD, GREEN, GREEN_BOLD, WARNING, WARNING_BOLD, format_with_gutter,
};

use super::hooks::{HookFailureStrategy, HookPipeline};
use super::project_config::load_project_config;

/// Result of a worktree switch operation
pub enum SwitchResult {
    /// Switched to existing worktree at the given path
    ExistingWorktree(PathBuf),
    /// Created new worktree at the given path
    CreatedWorktree {
        path: PathBuf,
        created_branch: bool,
        base_branch: Option<String>,
    },
}

impl SwitchResult {
    /// Get the worktree path
    pub fn path(&self) -> &PathBuf {
        match self {
            SwitchResult::ExistingWorktree(path) => path,
            SwitchResult::CreatedWorktree { path, .. } => path,
        }
    }
}

/// Result of a worktree remove operation
pub enum RemoveResult {
    /// Already on default branch, no action taken
    AlreadyOnDefault(String),
    /// Removed worktree and returned to primary (if needed)
    RemovedWorktree {
        primary_path: PathBuf,
        worktree_path: PathBuf,
        changed_directory: bool,
        branch_name: String,
        no_delete_branch: bool,
    },
    /// Switched to default branch in main repo
    SwitchedToDefault(String),
}

pub fn handle_switch(
    branch: &str,
    create: bool,
    base: Option<&str>,
    force: bool,
    no_verify: bool,
    config: &WorktrunkConfig,
) -> Result<(SwitchResult, String), GitError> {
    let repo = Repository::current();

    // Resolve special branch names ("@" for current, "-" for previous)
    let resolved_branch = repo.resolve_worktree_name(branch)?;

    // Resolve base if provided
    let resolved_base = if let Some(base_str) = base {
        Some(repo.resolve_worktree_name(base_str)?)
    } else {
        None
    };

    // Check for conflicting conditions
    if create && repo.local_branch_exists(&resolved_branch)? {
        return Err(GitError::BranchAlreadyExists {
            branch: resolved_branch.clone(),
        });
    }

    // Check if base flag was provided without create flag
    if resolved_base.is_some() && !create {
        crate::output::warning(format!(
            "{WARNING}--base flag is only used with --create, ignoring{WARNING:#}"
        ))?;
    }

    // Check if worktree already exists for this branch
    match repo.worktree_for_branch(&resolved_branch)? {
        Some(existing_path) if existing_path.exists() => {
            // Canonicalize the path for cleaner display
            let canonical_existing_path = existing_path.canonicalize().unwrap_or(existing_path);
            return Ok((
                SwitchResult::ExistingWorktree(canonical_existing_path),
                resolved_branch,
            ));
        }
        Some(_) => {
            return Err(GitError::WorktreeMissing {
                branch: resolved_branch.clone(),
            });
        }
        None => {}
    }

    // No existing worktree, create one
    let repo_root = repo.worktree_base()?;

    let repo_name = repo_root
        .file_name()
        .ok_or_else(|| GitError::CommandFailed("Invalid repository path".to_string()))?
        .to_str()
        .ok_or_else(|| GitError::CommandFailed("Invalid UTF-8 in path".to_string()))?;

    let worktree_path = repo_root.join(config.format_path(repo_name, &resolved_branch));

    // Create the worktree
    // Build git worktree add command
    let mut args = vec!["worktree", "add", worktree_path.to_str().unwrap()];

    // Use the resolved base, or default to default branch if creating without a base
    let base_for_creation = if create {
        match resolved_base {
            Some(b) => Some(b),
            None => Some(repo.resolve_target_branch(None)?),
        }
    } else {
        None
    };

    // Build args based on whether we're creating or checking out
    if create {
        args.push("-b");
        args.push(&resolved_branch);
        if let Some(ref base_branch) = base_for_creation {
            args.push(base_branch);
        }
    } else {
        args.push(&resolved_branch);
    }

    // Create worktree and parse specific error cases
    if let Err(e) = repo.run_command(&args) {
        // Check if error is about directory already existing
        if let GitError::CommandFailed(ref msg) = e
            && msg.contains("already exists")
        {
            // Parse the path from git's error message
            // Format: "fatal: '/path/to/dir' already exists"
            if let Some(path_str) = msg
                .lines()
                .find(|line| line.contains("already exists"))
                .and_then(|line| {
                    // Extract path between quotes
                    line.split('\'').nth(1).or_else(|| line.split('"').nth(1))
                })
            {
                let path = std::path::PathBuf::from(path_str);
                // Canonicalize if possible, otherwise use as-is
                let normalized_path = path.canonicalize().unwrap_or(path);
                return Err(GitError::WorktreePathExists {
                    path: normalized_path,
                });
            }
        }
        // Fall back to generic error with context
        return Err(e).git_context("Failed to create worktree");
    }

    // Canonicalize the path to resolve any .. components
    let worktree_path = worktree_path
        .canonicalize()
        .git_context("Failed to canonicalize worktree path")?;

    // Execute post-create commands (sequential, blocking)
    // Note: If user declines, continue anyway - worktree already created
    if !no_verify
        && let Err(e) =
            execute_post_create_commands(&worktree_path, &repo, config, &resolved_branch, force)
    {
        // Only treat CommandNotApproved as non-fatal (user declined)
        // Other errors should still fail
        if !matches!(e, GitError::CommandNotApproved) {
            return Err(e);
        }
    }

    // Note: post-start commands are spawned AFTER success message is shown
    // (see main.rs switch handler for temporal locality)

    Ok((
        SwitchResult::CreatedWorktree {
            path: worktree_path,
            created_branch: create,
            base_branch: base_for_creation,
        },
        resolved_branch,
    ))
}

pub fn handle_remove(
    worktree_name: Option<&str>,
    no_delete_branch: bool,
) -> Result<RemoveResult, GitError> {
    let repo = Repository::current();

    // Resolve "@" to current branch early so progress message shows resolved name
    let resolved_name = if let Some(name) = worktree_name {
        Some(repo.resolve_worktree_name(name)?)
    } else {
        None
    };

    // Show progress with resolved name
    let progress_msg = if let Some(ref b) = resolved_name {
        format!("{CYAN}Removing worktree for {CYAN_BOLD}{b}{CYAN_BOLD:#}...{CYAN:#}")
    } else {
        format!("{CYAN}Removing worktree...{CYAN:#}")
    };
    crate::output::progress(progress_msg)?;

    // Two modes: remove current worktree vs. remove by name
    match resolved_name.as_deref() {
        None => remove_current_worktree(&repo, no_delete_branch),
        Some(name) => remove_worktree_by_name(&repo, name, no_delete_branch),
    }
}

/// Remove the current worktree (original behavior)
fn remove_current_worktree(
    repo: &Repository,
    no_delete_branch: bool,
) -> Result<RemoveResult, GitError> {
    // Check for uncommitted changes in current worktree
    repo.ensure_clean_working_tree()?;

    // Check if we're in a worktree (fast - just checks git metadata)
    let in_worktree = repo.is_in_worktree()?;

    if in_worktree {
        // In worktree: navigate to primary worktree and remove this one
        // (no need to check default branch in this path)
        let worktree_root = repo.worktree_root()?;
        let current_branch = repo
            .current_branch()?
            .ok_or_else(|| GitError::CommandFailed("Not on a branch".to_string()))?;
        let worktrees = repo.list_worktrees()?;
        let primary_worktree_dir = worktrees.worktrees[0].path.clone();

        // Return paths - deletion will happen in output handler after cd directive is emitted
        Ok(RemoveResult::RemovedWorktree {
            primary_path: primary_worktree_dir,
            worktree_path: worktree_root,
            changed_directory: true, // We're in the worktree being removed
            branch_name: current_branch,
            no_delete_branch,
        })
    } else {
        // In main repo: check if already on default branch
        // Only fetch default_branch if needed (can be slow - network call)
        let current_branch = repo.current_branch()?;
        let default_branch = repo.default_branch()?;

        if current_branch.as_deref() == Some(&default_branch) {
            return Ok(RemoveResult::AlreadyOnDefault(default_branch));
        }

        // Switch to default branch
        repo.run_command(&["switch", &default_branch])
            .git_context(&format!("Failed to switch to '{}'", default_branch))?;

        Ok(RemoveResult::SwitchedToDefault(default_branch))
    }
}

/// Remove a worktree by branch name (branch_name should already be resolved)
fn remove_worktree_by_name(
    repo: &Repository,
    branch_name: &str,
    no_delete_branch: bool,
) -> Result<RemoveResult, GitError> {
    // Find the worktree for this branch
    let worktree_path = repo.worktree_for_branch(branch_name)?;

    let worktree_path = match worktree_path {
        Some(path) => path,
        None => {
            return Err(GitError::NoWorktreeFound {
                branch: branch_name.to_string(),
            });
        }
    };

    // Check if the target worktree exists on disk
    if !worktree_path.exists() {
        return Err(GitError::WorktreeMissing {
            branch: branch_name.to_string(),
        });
    }

    // Check if the target worktree is clean (no uncommitted changes)
    let target_repo = Repository::at(&worktree_path);
    target_repo.ensure_clean_working_tree()?;

    // Get the current worktree root to check if we're removing ourselves
    let current_worktree = repo.worktree_root()?;
    let removing_current = current_worktree == worktree_path;

    // Return paths for all cases - deletion happens in output handler
    let (primary_path, changed_directory) = if removing_current {
        // Removing current worktree - will cd to primary worktree
        let worktrees = repo.list_worktrees()?;
        (worktrees.worktrees[0].path.clone(), true)
    } else {
        // Removing different worktree - stay in current location
        (repo.worktree_root()?, false)
    };

    Ok(RemoveResult::RemovedWorktree {
        primary_path,
        worktree_path,
        changed_directory,
        branch_name: branch_name.to_string(),
        no_delete_branch,
    })
}

/// Auto-stash dirty target worktree changes when safe (no overlapping files)
fn prepare_target_worktree(
    repo: &Repository,
    target_worktree: Option<&std::path::PathBuf>,
    target_branch: &str,
) -> Result<Option<TargetWorktreeStash>, GitError> {
    let Some(wt_path) = target_worktree else {
        return Ok(None);
    };

    let wt_repo = Repository::at(wt_path);
    if !wt_repo.is_dirty()? {
        return Ok(None);
    }

    // Get files changed in the push
    let push_files = repo.changed_files(target_branch, "HEAD")?;

    // Get files changed in the worktree
    let wt_status_output = wt_repo.run_command(&["status", "--porcelain"])?;

    let wt_files: Vec<String> = wt_status_output
        .lines()
        .filter_map(|line| {
            // Parse porcelain format: "XY filename"
            line.split_once(' ')
                .map(|(_, filename)| filename.trim().to_string())
        })
        .collect();

    // Find overlapping files
    let overlapping: Vec<String> = push_files
        .iter()
        .filter(|f| wt_files.contains(f))
        .cloned()
        .collect();

    if !overlapping.is_empty() {
        return Err(GitError::ConflictingChanges {
            files: overlapping,
            worktree_path: wt_path.to_path_buf(),
        });
    }

    // Generate unique stash label so we can restore the exact entry even if others are created
    let nanos = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_nanos();
    let stash_name = format!(
        "worktrunk autostash::{}::{}::{}",
        target_branch,
        std::process::id(),
        nanos
    );

    crate::output::progress(format!(
        "{CYAN}Stashing changes in {CYAN_BOLD}{}{CYAN_BOLD:#}{CYAN}...{CYAN:#}",
        wt_path.display()
    ))?;

    let stash_output =
        wt_repo.run_command(&["stash", "push", "--include-untracked", "-m", &stash_name])?;

    if stash_output.contains("No local changes to save") {
        return Ok(None);
    }

    let list_output = wt_repo.run_command(&["stash", "list", "--format=%gd%x00%gs%x00"])?;
    let mut parts = list_output.split('\0');
    let mut stash_ref = None;
    while let Some(id) = parts.next() {
        if id.is_empty() {
            continue;
        }
        if let Some(message) = parts.next()
            && (message == stash_name || message.ends_with(&stash_name))
        {
            stash_ref = Some(id.to_string());
            break;
        }
    }

    let Some(stash_ref) = stash_ref else {
        return Err(GitError::CommandFailed(format!(
            "Failed to locate autostash entry '{}'",
            stash_name
        )));
    };

    Ok(Some(TargetWorktreeStash::new(wt_path, stash_ref)))
}

/// Auto-restores stashed changes in the target worktree after push completes
struct TargetWorktreeStash {
    repo: Repository,
    path: std::path::PathBuf,
    stash_ref: String,
}

impl TargetWorktreeStash {
    fn new(path: &std::path::Path, stash_ref: String) -> Self {
        Self {
            repo: Repository::at(path),
            path: path.to_path_buf(),
            stash_ref,
        }
    }

    fn restore(self) -> Result<(), GitError> {
        crate::output::progress(format!(
            "{CYAN}Restoring stashed changes in {CYAN_BOLD}{}{CYAN_BOLD:#}{CYAN}...{CYAN:#}",
            self.path.display()
        ))?;

        if let Err(_e) = self
            .repo
            .run_command(&["stash", "pop", "--quiet", &self.stash_ref])
        {
            crate::output::warning(format!(
                "{WARNING}Failed to restore stash {WARNING_BOLD}{stash_ref}{WARNING_BOLD:#}{WARNING} - run 'git stash pop {stash_ref}' in {WARNING_BOLD}{path}{WARNING_BOLD:#}{WARNING:#}",
                stash_ref = self.stash_ref,
                path = self.path.display(),
            ))?;
        }

        Ok(())
    }
}

/// Execute post-create commands sequentially (blocking)
pub fn execute_post_create_commands(
    worktree_path: &std::path::Path,
    repo: &Repository,
    config: &WorktrunkConfig,
    branch: &str,
    force: bool,
) -> Result<(), GitError> {
    let project_config = match load_project_config(repo)? {
        Some(cfg) => cfg,
        None => return Ok(()),
    };

    let Some(post_create_config) = &project_config.post_create_command else {
        return Ok(());
    };

    let repo_root = repo.worktree_base()?;
    let pipeline = HookPipeline::new(repo, config, branch, worktree_path, &repo_root, force);
    pipeline.run_sequential(
        post_create_config,
        CommandPhase::PostCreate,
        false,
        &[],
        "post-create",
        HookFailureStrategy::Warn,
    )
}

/// Spawn post-start commands in parallel as background processes (non-blocking)
pub fn spawn_post_start_commands(
    worktree_path: &std::path::Path,
    repo: &Repository,
    config: &WorktrunkConfig,
    branch: &str,
    force: bool,
) -> Result<(), GitError> {
    let project_config = match load_project_config(repo)? {
        Some(cfg) => cfg,
        None => return Ok(()),
    };

    let Some(post_start_config) = &project_config.post_start_command else {
        return Ok(());
    };

    let repo_root = repo.worktree_base()?;
    let pipeline = HookPipeline::new(repo, config, branch, worktree_path, &repo_root, force);
    pipeline.spawn_detached(
        post_start_config,
        CommandPhase::PostStart,
        false,
        &[],
        "post-start",
    )
}

/// Execute post-start commands sequentially (blocking) - for testing
pub fn execute_post_start_commands_sequential(
    worktree_path: &std::path::Path,
    repo: &Repository,
    config: &WorktrunkConfig,
    branch: &str,
    force: bool,
) -> Result<(), GitError> {
    let project_config = match load_project_config(repo)? {
        Some(cfg) => cfg,
        None => return Ok(()),
    };

    let Some(post_start_config) = &project_config.post_start_command else {
        return Ok(());
    };

    let repo_root = repo.worktree_base()?;
    let pipeline = HookPipeline::new(repo, config, branch, worktree_path, &repo_root, force);
    pipeline.run_sequential(
        post_start_config,
        CommandPhase::PostStart,
        false,
        &[],
        "post-start",
        HookFailureStrategy::Warn,
    )
}

/// Push changes to target branch
///
/// The `committed`, `squashed`, and `rebased` parameters are optional flags indicating
/// whether those operations occurred in the merge workflow. Pass `None` for standalone
/// push operations where these concepts don't apply.
///
/// During the push stage we temporarily `git stash` non-overlapping changes in the
/// target worktree (if present) so that concurrent edits there do not block the
/// fast-forward. The stash is restored afterward and we bail out early if any file
/// overlaps with the push range.
pub fn handle_push(
    target: Option<&str>,
    allow_merge_commits: bool,
    verb: &str,
    committed: Option<bool>,
    squashed: Option<bool>,
    rebased: Option<bool>,
) -> Result<(), GitError> {
    let repo = Repository::current();

    // Get target branch (default to default branch if not provided)
    let target_branch = repo.resolve_target_branch(target)?;

    // Check if it's a fast-forward
    if !repo.is_ancestor(&target_branch, "HEAD")? {
        // Get formatted commit log (commits in target that we don't have)
        let commits_formatted = repo
            .run_command(&[
                "log",
                "--color=always",
                "--graph",
                "--oneline",
                "--decorate",
                &format!("HEAD..{}", target_branch),
            ])?
            .trim()
            .to_string();

        // Get formatted diff stat
        let term_width = crate::display::get_terminal_width();
        let files_formatted = repo
            .run_command(&[
                "diff",
                "--color=always",
                "--stat",
                &format!("--stat-width={}", term_width),
                &format!("HEAD...{}", target_branch),
            ])?
            .trim_end()
            .to_string();

        return Err(GitError::NotFastForward {
            target_branch: target_branch.to_string(),
            commits_formatted,
            files_formatted,
        });
    }

    // Check for merge commits unless allowed
    let has_merge_commits = repo.has_merge_commits(&target_branch, "HEAD")?;
    if !allow_merge_commits && has_merge_commits {
        return Err(GitError::MergeCommitsFound);
    }

    // Configure receive.denyCurrentBranch if needed
    let current_config = repo.get_config("receive.denyCurrentBranch")?;
    if current_config.as_deref() != Some("updateInstead") {
        repo.set_config("receive.denyCurrentBranch", "updateInstead")?;
    }

    // Check for conflicting changes in target worktree (auto-stash safe changes)
    let target_worktree = repo.worktree_for_branch(&target_branch)?;
    let mut target_worktree_stash =
        prepare_target_worktree(&repo, target_worktree.as_ref(), &target_branch)?;

    // Count commits and show what will be pushed
    let commit_count = repo.count_commits(&target_branch, "HEAD")?;

    // Get diff statistics BEFORE push (will be needed for success message later)
    let stats_summary = if commit_count > 0 {
        repo.diff_stats_summary(&["diff", "--shortstat", &format!("{}..HEAD", target_branch)])
    } else {
        Vec::new()
    };

    // Build and show consolidated message with squash/rebase info
    if commit_count > 0 {
        let commit_text = if commit_count == 1 {
            "commit"
        } else {
            "commits"
        };
        let head_sha = repo.run_command(&["rev-parse", "--short", "HEAD"])?;
        let head_sha = head_sha.trim();

        let verb_ing = if verb.starts_with("Merged") {
            "Merging"
        } else {
            "Pushing"
        };

        let cyan_dim = CYAN.dimmed();

        // Build parenthetical showing which operations didn't happen and flags used
        let mut notes = Vec::new();

        // Skipped operations - only include if we're in merge workflow context (Some values)
        if committed.is_some() || squashed.is_some() || rebased.is_some() {
            let mut skipped_ops = Vec::new();
            if !committed.unwrap_or(false) && !squashed.unwrap_or(false) {
                // Neither commit nor squash happened - combine them
                skipped_ops.push("commit/squash");
            }
            if !rebased.unwrap_or(false) {
                skipped_ops.push("rebase");
            }
            if !skipped_ops.is_empty() {
                notes.push(format!("no {} needed", skipped_ops.join("/")));
            }
        }

        // Flag acknowledgments
        if allow_merge_commits && has_merge_commits {
            notes.push("merge commits allowed".to_string());
        }

        let operations_note = if notes.is_empty() {
            String::new()
        } else {
            format!(" ({})", notes.join(", "))
        };

        crate::output::progress(format!(
            "{CYAN}{verb_ing} {commit_count} {commit_text} to {CYAN_BOLD}{target_branch}{CYAN_BOLD:#}{CYAN} @ {cyan_dim}{head_sha}{cyan_dim:#}{CYAN:#}{operations_note}\n"
        ))?;

        // Show the commit graph with color
        let log_output = repo.run_command(&[
            "log",
            "--color=always",
            "--graph",
            "--oneline",
            "--decorate",
            &format!("{}..HEAD", target_branch),
        ])?;
        crate::output::gutter(format_with_gutter(&log_output, "", None))?;

        // Show diff statistics with color (use terminal width for proper formatting)
        let term_width = crate::display::get_terminal_width();
        let diff_stat = repo.run_command(&[
            "diff",
            "--color=always",
            "--stat",
            &format!("--stat-width={}", term_width),
            &format!("{}..HEAD", target_branch),
        ])?;

        let diff_stat = diff_stat.trim_end();
        if !diff_stat.is_empty() {
            crate::output::gutter(format_with_gutter(diff_stat, "", None))?;
        }
    }

    // Get git common dir for the push
    let git_common_dir = repo.git_common_dir()?;

    // Perform the push
    let push_target = format!("HEAD:{}", target_branch);
    if let Err(e) = repo.run_command(&["push", git_common_dir.to_str().unwrap(), &push_target]) {
        if let Some(stash) = target_worktree_stash.take() {
            stash.restore()?;
        }
        return Err(GitError::PushFailed {
            error: e.to_string(),
        });
    }

    if let Some(stash) = target_worktree_stash.take() {
        stash.restore()?;
    }

    // Show success message after push completes
    if commit_count > 0 {
        // Use the diff statistics captured earlier (before push)
        let mut summary_parts = vec![format!(
            "{} commit{}",
            commit_count,
            if commit_count == 1 { "" } else { "s" }
        )];
        summary_parts.extend(stats_summary);

        crate::output::success(format!(
            "{GREEN}{verb} {GREEN_BOLD}{target_branch}{GREEN_BOLD:#}{GREEN:#} ({})",
            summary_parts.join(", ")
        ))?;
    } else {
        // No commits to push - for merge workflow context, acknowledge operations that didn't happen
        let note = if committed.is_some() || squashed.is_some() || rebased.is_some() {
            let mut notes = Vec::new();
            if !committed.unwrap_or(false) && !squashed.unwrap_or(false) {
                notes.push("no new commits");
            }
            if !rebased.unwrap_or(false) {
                notes.push("no rebase needed");
            }
            if notes.is_empty() {
                String::new()
            } else {
                format!(" ({})", notes.join(", "))
            }
        } else {
            // Standalone push - no merge workflow context
            String::new()
        };

        crate::output::success(format!(
            "{GREEN}{verb} {GREEN_BOLD}{target_branch}{GREEN_BOLD:#}{GREEN:#}{note}"
        ))?;
    }

    Ok(())
}
