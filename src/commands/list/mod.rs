//! List command for displaying worktrees and branches.
//!
//! # Performance
//!
//! `wt list` runs multiple git commands per worktree in parallel using Rayon. Performance
//! depends heavily on git's internal caches, not worktrunk-specific caching.
//!
//! ## Time to First Information
//!
//! Before displaying actual data, we perform these sequential operations:
//!
//! 1. **`git worktree list --porcelain`** (~5-15ms)
//!    - Lists all worktrees with their paths, HEADs, and branches
//!    - Uses ref cache, very fast
//!
//! 2. **Default branch lookup** (~1-5ms)
//!    - Reads cached value from `.git/refs/remotes/origin/HEAD`
//!    - Falls back to `git remote show origin` if not cached (~100-300ms network)
//!    - Refresh with `wt config state get default-branch --refresh`
//!
//! 3. **Sort worktrees** (<1ms)
//!    - Orders by: current → main → rest by timestamp (most recent first)
//!    - Pure Rust, no git calls
//!
//! 4. **Branch listing** (only with `--branches`, ~10-30ms)
//!    - `git for-each-ref refs/heads` - lists local branches
//!    - Filters out branches that already have worktrees
//!
//! 5. **Remote branch listing** (only with `--remotes`, ~10-50ms)
//!    - `git for-each-ref refs/remotes` - lists remote branches
//!    - Scales with number of remotes/branches
//!
//! 6. **Layout calculation** (<1ms)
//!    - Determines column widths from branch names and paths
//!    - Pure Rust, no git calls
//!
//! **Time to skeleton: ~50ms** (placeholder rows with loading indicators)
//!
//! Skeleton timing is stable at ~46-52ms regardless of worktree count (1-8) or cache state.
//! This is because skeleton operations (worktree list, default branch lookup, layout) use
//! git's ref cache rather than packed-refs or the index.
//!
//! **Time to complete: ~60-170ms** (all data filled in, depends on worktree count)
//!
//! First run in a repo without cached default branch adds ~100-300ms for network lookup.
//!
//! After the skeleton appears, cells fill in progressively as git operations complete.
//! The slowest operation (CI status) only runs with `--full`.
//!
//! ## Git Commands Per Worktree
//!
//! For each worktree, we execute:
//! - `git status --porcelain` - Working tree state (uses index cache)
//! - `git rev-list --count <base>..<head>` - Ahead/behind counts (uses commit graph)
//! - `git diff --numstat HEAD` - Working tree line diffs (uses index + tree objects)
//! - `git diff --numstat <base>...<head>` - Branch line diffs (uses tree objects)
//! - `git rev-parse <ref>` - Ref resolution (uses ref cache)
//!
//! Plus one global command:
//! - `git worktree list --porcelain` - List all worktrees (uses ref cache)
//!
//! ## Git's Internal Caches
//!
//! Git caches significantly affect performance. These caches are maintained by git itself:
//!
//! 1. **Index (`.git/index`)** - Cached file metadata (mtime, size, mode)
//!    - Speeds up `git status` by avoiding full file content comparisons
//!    - Invalidated when files change or staging area updates
//!    - Cold: ~100ms per worktree, Warm: ~10ms per worktree (typical repo)
//!
//! 2. **Commit graph (`.git/objects/info/commit-graph`)** - Precomputed commit metadata
//!    - Speeds up `git rev-list --count` by avoiding commit object parsing
//!    - Generated by `git commit-graph write` (some repos auto-generate)
//!    - Without: O(commits) parsing, With: O(1) metadata lookup
//!    - Cold: ~50ms for 1000 commits, Warm: ~5ms (with commit graph)
//!
//! 3. **Ref cache (`.git/refs/` and `.git/packed-refs`)** - Cached ref resolutions
//!    - Speeds up `git rev-parse` and branch lookups
//!    - Packed refs improve performance in repos with many branches
//!    - Cold: ~10ms, Warm: <1ms
//!
//! 4. **Filesystem cache (OS-level)** - Recently accessed files stay in memory
//!    - Speeds up all git operations after first access
//!    - Cleared when system is under memory pressure
//!    - Most impactful for large repos with many pack files
//!
//! 5. **Pack files (`.git/objects/pack/`)** - Compressed object storage
//!    - Faster than loose objects for bulk access
//!    - `git gc` consolidates loose objects into packs
//!    - More efficient for tree/blob access in diffs
//!
//! ## Worktrunk's Only Cache: Default Branch
//!
//! Worktrunk caches only the default branch name (main/master) using `git remote set-head`.
//! This is a git-native cache stored in `.git/refs/remotes/origin/HEAD`. All other data is
//! fetched fresh on each `wt list` invocation.
//!
//! Refresh with: `wt config state get default-branch --refresh`
//!
//! ## Performance Characteristics
//!
//! Scaling (from benches/list.rs):
//! - Linear with worktree count due to parallelization (Rayon thread pool)
//! - Dominated by git command overhead, not Rust code
//! - Cold caches: ~150-300ms per worktree (typical repo, 500 commits, 100 files)
//! - Warm caches: ~20-50ms per worktree
//! - Real-world: rust-lang/rust repo with 8 worktrees: ~400ms (warm caches)
//!
//! Bottlenecks:
//! 1. `git status --porcelain` - Slowest when index is cold or many files changed
//! 2. `git rev-list --count` - Slow without commit graph in repos with deep history
//! 3. `git diff --numstat` - Slow for large diffs or when pack files aren't cached
//!
//! Optimization tips:
//! - Run `git commit-graph write --reachable --changed-paths` to speed up commit counting
//! - Run `git gc` periodically to consolidate objects into pack files
//! - Minimize uncommitted changes across worktrees (each dirty worktree adds diff overhead)

pub mod ci_status;
pub(crate) mod collect;
mod collect_progressive_impl;
mod columns;
mod json_output;
pub(crate) mod layout;
pub mod model;
pub mod progressive;
mod progressive_table;
pub(crate) mod render;

#[cfg(test)]
mod spacing_test;

// Layout is calculated in collect.rs
use anyhow::Context;
use model::{ListData, ListItem};
use progressive::RenderMode;
use worktrunk::git::Repository;

// Re-export for statusline and other consumers
pub use collect::{CollectOptions, build_worktree_item, populate_item};

pub fn handle_list(
    format: crate::OutputFormat,
    show_branches: bool,
    show_remotes: bool,
    show_full: bool,
    render_mode: RenderMode,
    config: &worktrunk::config::WorktrunkConfig,
) -> anyhow::Result<()> {
    use collect::TaskKind;

    let repo = Repository::current();

    // Build skip set based on flags
    // Without --full: skip expensive operations (BranchDiff, CiStatus)
    // TODO: WouldMergeAdd (~500ms-2s per worktree) is currently enabled for ⊂ detection.
    // If this causes performance issues, consider adding it back to skip_tasks or
    // implementing a timeout for the merge simulation.
    let skip_tasks: std::collections::HashSet<TaskKind> = if show_full {
        std::collections::HashSet::new() // Compute everything
    } else {
        [TaskKind::BranchDiff, TaskKind::CiStatus]
            .into_iter()
            .collect()
    };

    // Progressive rendering only for table format with Progressive mode
    let show_progress = match format {
        crate::OutputFormat::Table => render_mode == RenderMode::Progressive,
        crate::OutputFormat::Json => false, // JSON never shows progress
    };

    // Render table in collect() for all table modes (progressive + buffered)
    let render_table = matches!(format, crate::OutputFormat::Table);

    let list_data = collect::collect(
        &repo,
        show_branches,
        show_remotes,
        &skip_tasks,
        show_progress,
        render_table,
        config,
    )?;

    let Some(ListData { items, .. }) = list_data else {
        return Ok(());
    };

    match format {
        crate::OutputFormat::Json => {
            // Convert to new JSON structure
            let json_items = json_output::to_json_items(&items);
            let json =
                serde_json::to_string_pretty(&json_items).context("Failed to serialize to JSON")?;
            crate::output::data(json)?;
        }
        crate::OutputFormat::Table => {
            // Table and summary already rendered in collect() for all modes
            // Nothing to do here - collect() handles the complete table rendering
        }
    }

    // Show hint if CI status was requested but no tools can fetch it.
    // Skip the check if any items already have CI status (tools must be available).
    if show_full {
        // pr_status semantics: None = not fetched, Some(None) = fetched but no PR,
        // Some(Some(status)) = fetched with status. If any item is Some(_), we
        // successfully communicated with CI tools, so they're available.
        let any_ci_fetched = items.iter().any(|item| item.pr_status.is_some());

        if any_ci_fetched {
            log::debug!("Skipping CI tools detection - CI status already fetched");
        } else {
            // No CI was fetched - run full detection to show helpful hint
            let gitlab_host = repo
                .worktree_root()
                .ok()
                .and_then(|p| p.to_str().map(|s| s.to_string()))
                .and_then(|p| ci_status::get_gitlab_host_for_repo(&p));
            let ci_tools = ci_status::CiToolsStatus::detect(gitlab_host.as_deref());

            if !ci_tools.any_available() {
                use ci_status::{CiPlatform, get_platform_for_repo};
                use color_print::cformat;
                use worktrunk::git::Repository;
                use worktrunk::styling::hint_message;

                // Detect platform from repo's remote URL
                let platform = Repository::current()
                    .worktree_root()
                    .ok()
                    .and_then(|root| get_platform_for_repo(root.to_str()?));

                // Only show hint for the relevant platform's tool
                let hint = match platform {
                    Some(CiPlatform::GitHub) => {
                        if ci_tools.gh_installed && !ci_tools.gh_authenticated {
                            Some(cformat!(
                                "CI status unavailable; run <bright-black>gh auth login</> to authenticate"
                            ))
                        } else if !ci_tools.gh_installed {
                            Some(cformat!(
                                "CI status unavailable; install <bright-black>gh</>"
                            ))
                        } else {
                            None
                        }
                    }
                    Some(CiPlatform::GitLab) => {
                        if ci_tools.glab_installed && !ci_tools.glab_authenticated {
                            Some(cformat!(
                                "CI status unavailable; run <bright-black>glab auth login</> to authenticate"
                            ))
                        } else if !ci_tools.glab_installed {
                            Some(cformat!(
                                "CI status unavailable; install <bright-black>glab</>"
                            ))
                        } else {
                            None
                        }
                    }
                    None => None, // Unknown platform - don't show any hint
                };

                if let Some(message) = hint {
                    crate::output::blank()?;
                    crate::output::print(hint_message(message))?;
                }
            }
        }
    }

    Ok(())
}

#[derive(Default)]
pub(super) struct SummaryMetrics {
    worktrees: usize,
    local_branches: usize,
    remote_branches: usize,
    dirty_worktrees: usize,
    ahead_items: usize,
}

impl SummaryMetrics {
    pub(super) fn from_items(items: &[ListItem]) -> Self {
        let mut metrics = Self::default();
        for item in items {
            metrics.update(item);
        }
        metrics
    }

    fn update(&mut self, item: &ListItem) {
        if let Some(_data) = item.worktree_data() {
            self.worktrees += 1;
            // Use status_symbols.working_tree which includes untracked files,
            // not just working_tree_diff which only has tracked changes
            if item
                .status_symbols
                .as_ref()
                .is_some_and(|s| s.working_tree.is_dirty())
            {
                self.dirty_worktrees += 1;
            }
        } else {
            // Distinguish local vs remote branches by presence of '/' in name
            // Remote branches are like "origin/feature", local are like "feature"
            if item.branch.as_ref().is_some_and(|b| b.contains('/')) {
                self.remote_branches += 1;
            } else {
                self.local_branches += 1;
            }
        }

        let counts = item.counts();
        if counts.ahead > 0 {
            self.ahead_items += 1;
        }
    }

    pub(super) fn summary_parts(
        &self,
        include_branches: bool,
        hidden_columns: usize,
    ) -> Vec<String> {
        let mut parts = Vec::new();

        if include_branches {
            parts.push(format!("{} worktrees", self.worktrees));
            if self.local_branches > 0 {
                parts.push(format!("{} branches", self.local_branches));
            }
            if self.remote_branches > 0 {
                parts.push(format!("{} remote branches", self.remote_branches));
            }
        } else {
            let plural = if self.worktrees == 1 { "" } else { "s" };
            parts.push(format!("{} worktree{}", self.worktrees, plural));
        }

        if self.dirty_worktrees > 0 {
            parts.push(format!("{} with changes", self.dirty_worktrees));
        }

        if self.ahead_items > 0 {
            parts.push(format!("{} ahead", self.ahead_items));
        }

        if hidden_columns > 0 {
            let plural = if hidden_columns == 1 {
                "column"
            } else {
                "columns"
            };
            parts.push(format!("{} {} hidden", hidden_columns, plural));
        }

        parts
    }
}

/// Format a summary message for the given items (used by both collect.rs and mod.rs)
pub(crate) fn format_summary_message(
    items: &[ListItem],
    show_branches: bool,
    hidden_column_count: usize,
) -> String {
    use anstyle::Style;
    use worktrunk::styling::INFO_SYMBOL;

    let metrics = SummaryMetrics::from_items(items);
    let dim = Style::new().dimmed();
    let summary = metrics
        .summary_parts(show_branches, hidden_column_count)
        .join(", ");
    format!("{INFO_SYMBOL} {dim}Showing {summary}{dim:#}")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_summary_metrics_default() {
        let metrics = SummaryMetrics::default();
        assert_eq!(metrics.worktrees, 0);
        assert_eq!(metrics.local_branches, 0);
        assert_eq!(metrics.remote_branches, 0);
        assert_eq!(metrics.dirty_worktrees, 0);
        assert_eq!(metrics.ahead_items, 0);
    }

    #[test]
    fn test_summary_metrics_summary_parts_single_worktree() {
        let metrics = SummaryMetrics {
            worktrees: 1,
            local_branches: 0,
            remote_branches: 0,
            dirty_worktrees: 0,
            ahead_items: 0,
        };
        let parts = metrics.summary_parts(false, 0);
        assert_eq!(parts, vec!["1 worktree"]);
    }

    #[test]
    fn test_summary_metrics_summary_parts_multiple_worktrees() {
        let metrics = SummaryMetrics {
            worktrees: 3,
            local_branches: 0,
            remote_branches: 0,
            dirty_worktrees: 0,
            ahead_items: 0,
        };
        let parts = metrics.summary_parts(false, 0);
        assert_eq!(parts, vec!["3 worktrees"]);
    }

    #[test]
    fn test_summary_metrics_summary_parts_with_branches() {
        let metrics = SummaryMetrics {
            worktrees: 2,
            local_branches: 5,
            remote_branches: 10,
            dirty_worktrees: 0,
            ahead_items: 0,
        };
        let parts = metrics.summary_parts(true, 0);
        assert_eq!(
            parts,
            vec!["2 worktrees", "5 branches", "10 remote branches"]
        );
    }

    #[test]
    fn test_summary_metrics_summary_parts_with_dirty() {
        let metrics = SummaryMetrics {
            worktrees: 3,
            local_branches: 0,
            remote_branches: 0,
            dirty_worktrees: 2,
            ahead_items: 0,
        };
        let parts = metrics.summary_parts(false, 0);
        assert_eq!(parts, vec!["3 worktrees", "2 with changes"]);
    }

    #[test]
    fn test_summary_metrics_summary_parts_with_ahead() {
        let metrics = SummaryMetrics {
            worktrees: 2,
            local_branches: 0,
            remote_branches: 0,
            dirty_worktrees: 0,
            ahead_items: 1,
        };
        let parts = metrics.summary_parts(false, 0);
        assert_eq!(parts, vec!["2 worktrees", "1 ahead"]);
    }

    #[test]
    fn test_summary_metrics_summary_parts_with_hidden_columns() {
        let metrics = SummaryMetrics {
            worktrees: 1,
            local_branches: 0,
            remote_branches: 0,
            dirty_worktrees: 0,
            ahead_items: 0,
        };
        let parts = metrics.summary_parts(false, 1);
        assert_eq!(parts, vec!["1 worktree", "1 column hidden"]);

        let parts = metrics.summary_parts(false, 3);
        assert_eq!(parts, vec!["1 worktree", "3 columns hidden"]);
    }

    #[test]
    fn test_summary_metrics_summary_parts_branches_no_local() {
        let metrics = SummaryMetrics {
            worktrees: 2,
            local_branches: 0,
            remote_branches: 5,
            dirty_worktrees: 0,
            ahead_items: 0,
        };
        let parts = metrics.summary_parts(true, 0);
        assert_eq!(parts, vec!["2 worktrees", "5 remote branches"]);
    }

    #[test]
    fn test_summary_metrics_summary_parts_all_features() {
        let metrics = SummaryMetrics {
            worktrees: 5,
            local_branches: 3,
            remote_branches: 8,
            dirty_worktrees: 2,
            ahead_items: 4,
        };
        let parts = metrics.summary_parts(true, 2);
        assert_eq!(
            parts,
            vec![
                "5 worktrees",
                "3 branches",
                "8 remote branches",
                "2 with changes",
                "4 ahead",
                "2 columns hidden"
            ]
        );
    }
}
