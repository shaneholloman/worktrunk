# Worktrunk Development Guidelines

> **Note**: This CLAUDE.md is just getting started. More guidelines will be added as patterns emerge.

## Project Status

**This project has no users yet and zero backward compatibility concerns.**

We are in **pre-release development** mode:
- Breaking changes are acceptable and expected
- No migration paths needed for config changes, API changes, or behavior changes
- Optimize for the best solution, not compatibility with previous versions
- Move fast and make bold improvements

When making decisions, prioritize:
1. **Best technical solution** over backward compatibility
2. **Clean design** over maintaining old patterns
3. **Modern conventions** over legacy approaches

Examples of acceptable breaking changes:
- Changing config file locations (e.g., moving from `~/Library/Application Support` to `~/.config`)
- Renaming commands or flags for clarity
- Changing output formats
- Replacing dependencies with better alternatives
- Restructuring the codebase

When the project reaches v1.0 or gains users, we'll adopt stability commitments. Until then, we're free to iterate rapidly.

## CLI Output Formatting Standards

### The anstyle Ecosystem

All styling uses the **anstyle ecosystem** for composable, auto-detecting terminal output:

- **`anstream`**: Auto-detecting I/O streams (println!, eprintln! macros)
- **`anstyle`**: Core styling with inline pattern `{style}text{style:#}`
- **Color detection**: Respects NO_COLOR, CLICOLOR_FORCE, TTY detection

### Message Types

Five canonical message patterns with their emojis:

1. **Progress**: üîÑ + cyan text (operations in progress)
2. **Success**: ‚úÖ + green text (successful completion)
3. **Errors**: ‚ùå + red text (failures, invalid states)
4. **Warnings**: üü° + yellow text (non-blocking issues)
5. **Hints**: üí° + dimmed text (helpful suggestions)

### stdout vs stderr: Separation by Source

**Core Principle: Separate output by who generates it, not by message type.**

- **stdout**: All output generated by worktrunk (messages, directives, data, errors, warnings, progress)
- **stderr**: All output generated by child processes (git, npm, user commands)

This creates clean semantic separation: "Is it from us or from a child process?"

**Benefits:**
- Simple reasoning: one decision point (source), not multiple (type, severity, etc.)
- No cross-stream coordination needed (no flushing stderr before stdout directives)
- Better for piping: `wt list | jq` gets clean data, `wt switch -x "npm install" 2>/dev/null` suppresses npm noise
- Child process output never interferes with our protocol (directives, structured output)

**Trade-off:**
- Violates Unix convention that errors go to stderr
- Our "errors" are structured program output (validation failures, formatted git errors), not unexpected crashes
- Panics and assertion failures still go to stderr via Rust's default handler (which is correct)

**Implementation:**
```rust
use worktrunk::styling::{println, ERROR, ERROR_EMOJI};

// ALL our output goes to stdout (including errors)
println!("{ERROR_EMOJI} {ERROR}Branch already exists{ERROR:#}");
println!("‚úÖ Created worktree");
println!("üí° Run 'wt list' to see all worktrees");
```

**Child processes:**
```rust
// Redirect child stdout to stderr so all child output goes there
let wrapped = format!("{{ {}; }} 1>&2", command);
Command::new("sh")
    .arg("-c")
    .arg(&wrapped)
    .stdout(Stdio::inherit())  // Actually goes to stderr due to redirect
    .stderr(Stdio::inherit())
    .status()?;
```

### Temporal Locality: Show Success When Actions Complete

**Principle: Emit success messages immediately when operations complete, not just in summaries.**

Users need instant feedback that an operation succeeded. Summaries at the end are useful for context, but immediate feedback at the point of completion is critical for good UX.

**Good pattern:**
```
üîÑ Squashing 3 commits into one...
üîÑ Generating squash commit message...
  [commit message display]
‚úÖ Squashed 3 commits into one          ‚Üê Immediate feedback
üîÑ Rebasing onto main...
...
‚úÖ Merged feature ‚Üí main                ‚Üê Final summary
Squashed 3 commits                      ‚Üê Context in summary
```

**Bad pattern:**
```
üîÑ Squashing 3 commits into one...
üîÑ Generating squash commit message...
  [commit message display]
                                        ‚Üê No immediate feedback!
üîÑ Rebasing onto main...
...
‚úÖ Merged feature ‚Üí main
Squashed 3 commits                      ‚Üê Only mentioned in summary
```

**Why this matters:**
- **Temporal locality**: Feedback should appear when the action completes, not minutes later
- **User confidence**: Immediate success messages confirm the operation worked
- **Debugging**: If something fails later, users know which steps succeeded
- **Progress visibility**: Users can see what's done vs. what's still in progress

**Implementation:**
```rust
// After completing a significant operation, emit success immediately
crate::output::success("Squashed 3 commits into one")?;

// The summary can still include this info for context
let summary = format!("Merged {from} ‚Üí {to}\nSquashed {count} commits\n...");
crate::output::success(summary)?;
```

**Apply this to:**
- Squashing commits: Show "‚úÖ Squashed N commits" immediately after squashing
- Pushing changes: Show "‚úÖ Pushed to branch" immediately after pushing
- Committing changes: Show "‚úÖ Committed changes" immediately after committing
- Any multi-step operation: Show success after each major step completes

### Semantic Style Constants

**Style constants defined in `src/styling.rs`:**

- **`ERROR`**: Red (errors, conflicts)
- **`WARNING`**: Yellow (warnings)
- **`HINT`**: Dimmed (hints, secondary information)
- **`CURRENT`**: Magenta + bold (current worktree)
- **`ADDITION`**: Green (diffs, additions)
- **`DELETION`**: Red (diffs, deletions)

**Emoji constants:**

- **`ERROR_EMOJI`**: ‚ùå (use with ERROR style)
- **`WARNING_EMOJI`**: üü° (use with WARNING style)
- **`HINT_EMOJI`**: üí° (use with HINT style)

### Inline Formatting Pattern

Use anstyle's inline pattern `{style}text{style:#}` where `#` means reset:

```rust
use worktrunk::styling::{println, ERROR, ERROR_EMOJI, WARNING, WARNING_EMOJI, HINT, HINT_EMOJI, AnstyleStyle};
use anstyle::{AnsiColor, Color};

// Progress
let cyan = AnstyleStyle::new().fg_color(Some(Color::Ansi(AnsiColor::Cyan)));
println!("üîÑ {cyan}Rebasing onto main...{cyan:#}");

// Success
let green = AnstyleStyle::new().fg_color(Some(Color::Ansi(AnsiColor::Green)));
println!("‚úÖ {green}Pushed to main{green:#}");

// Error - ALL our output goes to stdout
println!("{ERROR_EMOJI} {ERROR}Working tree has uncommitted changes{ERROR:#}");

// Warning - ALL our output goes to stdout
println!("{WARNING_EMOJI} {WARNING}Uncommitted changes detected{WARNING:#}");

// Hint
println!("{HINT_EMOJI} {HINT}Use 'wt list' to see all worktrees{HINT:#}");
```

### Composing Styles

Compose styles using anstyle methods (`.bold()`, `.fg_color()`, etc.):

```rust
use worktrunk::styling::{println, AnstyleStyle, ERROR, WARNING};

// Error with bold branch name
let error_bold = ERROR.bold();
println!("‚ùå Branch '{error_bold}{branch}{error_bold:#}' already exists");

// Warning with bold
let warning_bold = WARNING.bold();
println!("üü° {warning_bold}{message}{warning_bold:#}");

// Just bold (no color)
let bold = AnstyleStyle::new().bold();
println!("Switched to worktree: {bold}{branch}{bold:#}");
```

### Branch Name Formatting

**Always format branch names in bold** when they appear in messages:

```rust
use worktrunk::styling::{println, AnstyleStyle, ERROR};

// Good - bold branch name in error
let error_bold = ERROR.bold();
println!("‚ùå Branch '{error_bold}{branch}{error_bold:#}' already exists");

// Good - bold in regular message
let bold = AnstyleStyle::new().bold();
println!("Switched to worktree: {bold}{branch}{bold:#}");

// Bad - plain branch name
println!("Switched to worktree: {branch}")
```

### Information Hierarchy & Path Styling

**Principle: Bold what answers the user's question, dim what provides context.**

Style elements based on **user intent**, not data type. The same information (like a file path) can be primary in one context and secondary in another.

**File paths:**

- **Primary information** (answering the user's main question): **Bold**
  - Example: `wt config list` - paths are the answer to "where is my config?"

- **Secondary information** (contextual metadata): **Dim**
  - Example: `wt switch` output - path provides context, branch name is the answer

```rust
use worktrunk::styling::AnstyleStyle;

// Path as primary answer (config list)
let bold = AnstyleStyle::new().bold();
println!("Global Config: {bold}{}{bold:#}", path.display());

// Path as secondary context (switch output)
let dim = AnstyleStyle::new().dimmed();
println!("‚úÖ Created {bold}{branch}{bold:#}\n  {dim}Path: {}{dim:#}", path.display());
```

**Visual hierarchy patterns:**

| Element | Primary (answers question) | Secondary (provides context) |
|---------|---------------------------|------------------------------|
| Branch names | **Bold** (always) | **Bold** (always) |
| File paths | **Bold** (`config list`) | **Dim** (`switch` output) |
| Config values | Normal | **Dim** |
| Metadata | Dim | **Dim** |

### Indentation Policy

**Core Principle: No manual indentation for secondary information.**

Styling (bold, dim, color) already provides visual hierarchy. Manual indentation adds cognitive load without adding clarity.

**Rules:**

1. **Secondary paths, metadata**: No indent, use dimmed styling only
   ```rust
   // Good - dimming provides hierarchy
   println!("‚úÖ Created {bold}{branch}{bold:#}");
   println!("{dim}Path: {}{dim:#}", path.display());

   // Bad - unnecessary indent
   println!("‚úÖ Created {bold}{branch}{bold:#}");
   println!("  {dim}Path: {}{dim:#}", path.display());
   ```

2. **File lists (bullets)**: No indent, bullet provides visual separation
   ```rust
   // Good - bullet is enough
   for file in &files {
       println!("{dim}‚Ä¢{dim:#} {}", file);
   }

   // Bad - redundant indent
   for file in &files {
       println!("  {dim}‚Ä¢{dim:#} {}", file);
   }
   ```

3. **Log file paths**: No indent, dimming is sufficient
   ```rust
   // Good
   println!("{dim}Logs: {}{dim:#}", path);

   // Bad
   println!("  {dim}Logs: {}{dim:#}", path);
   ```

4. **Quoted content (commands, config)**: Use `format_with_gutter()` instead of manual indents
   ```rust
   // Good - gutter provides visual separation
   print!("{}", format_with_gutter(&command));

   // Bad - manual indentation
   for line in command.lines() {
       println!("  {}", line);
   }
   ```

**Exception:** Nested hierarchies where structural relationships must be clear (not yet encountered in this codebase).

**Rationale:**
- Styling already creates visual hierarchy
- Indentation is redundant cognitive load
- Simpler output is easier to scan
- Follows git's own output conventions

### Color Detection

Colors automatically adjust based on environment:
- Respects `NO_COLOR` (disables)
- Respects `CLICOLOR_FORCE` / `FORCE_COLOR` (enables)
- Auto-detects TTY (colors only on terminals)

All handled automatically by `anstream` macros.

### Design Principles

- **Inline over wrappers** - Use `{style}text{style:#}` pattern, not wrapper functions
- **Composition over special cases** - Use `.bold()`, `.fg_color()`, not `format_X_with_Y()`
- **Semantic constants** - Use `ERROR`, `WARNING`, not raw colors
- **YAGNI for presentation** - Most output needs no styling
- **Minimal output** - Only use formatting where it adds clarity
- **Unicode-aware** - Width calculations respect emoji and CJK characters (via `StyledLine`)
- **Graceful degradation** - Must work without color support

### Complete Examples

```rust
use worktrunk::styling::{
    eprintln, println, AnstyleStyle,
    ERROR, ERROR_EMOJI, WARNING, WARNING_EMOJI, HINT, HINT_EMOJI
};
use anstyle::Style;

// Simple error
println!("{ERROR_EMOJI} {ERROR}Working tree has uncommitted changes{ERROR:#}");

// Error with bold branch name
let error_bold = ERROR.bold();
println!("{ERROR_EMOJI} Branch '{error_bold}{branch}{error_bold:#}' already exists");

// Warning with bold
let warning_bold = WARNING.bold();
println!("{WARNING_EMOJI} {warning_bold}Uncommitted changes detected{warning_bold:#}");

// Hint
println!("{HINT_EMOJI} {HINT}Use 'wt list' to see all worktrees{HINT:#}");

// Bold branch name in regular message
let bold = Style::new().bold();
println!("Switched to worktree: {bold}{branch}{bold:#}");

// Complex multi-part error
let error_bold = ERROR.bold();
println!("{ERROR_EMOJI} Not a fast-forward from '{error_bold}{target_branch}{error_bold:#}' to HEAD");

// Dimmed secondary info
let dim = Style::new().dimmed();
println!("  {dim}Path: {path}{dim:#}");
```

### StyledLine API

For complex table formatting with proper width calculations, use `StyledLine`:

```rust
use worktrunk::styling::StyledLine;
use anstyle::{AnsiColor, Color, Style};

let mut line = StyledLine::new();
let dim = Style::new().dimmed();
let cyan = Style::new().fg_color(Some(Color::Ansi(AnsiColor::Cyan)));

line.push_styled("Branch", dim);
line.push_raw("  ");
line.push_styled("main", cyan);

println!("{}", line.render());
```

See `src/commands/list/render.rs` for advanced usage.

### Gutter Formatting for Quoted Content

The **gutter** is a subtle visual separator (single space with background color) used for quoted content like commands and configuration.

**Core Principle: Gutter provides all the separation needed**

The gutter's visual distinction is sufficient - no additional indentation required. This keeps the output clean and maximizes horizontal space for content.

#### Formatting Rules

1. **Gutter at column 0**: `format_with_gutter(content)`
   - Gutter appears at column 0
   - Content appears at column 1 (after the gutter + 1 space)
   - The colored background provides visual separation from surrounding text

2. **Preserve internal structure**: Multi-line content maintains its original formatting
   - Don't strip leading whitespace that's part of the content
   - Apply gutter treatment uniformly to each line

#### Examples

**Config display:**
```
Global Config: /path/to/config
 worktree-path = "../{main-worktree}.{branch}"

 [llm]
```

**Command approval:**
```
project wants to execute:
 [ -d {repo_root}/target ] &&
 [ ! -e {worktree}/target ] &&
 cp -cR {repo_root}/target/. {worktree}/target/
```

**Command execution:**
```
üîÑ Executing (post-create):
 npm install
```

#### Implementation

```rust
use worktrunk::styling::format_with_gutter;

// Simple usage - gutter provides all separation
print!("{}", format_with_gutter(&command));
print!("{}", format_with_gutter(&config));
```

**Function signature:**
```rust
/// Arguments:
/// - content: Text to format (preserves internal structure for multi-line)
pub fn format_with_gutter(content: &str) -> String
```

## Output System Architecture

### Two Output Modes

Worktrunk supports two output modes, selected once at program startup:

1. **Interactive Mode** - Human-friendly output with colors, emojis, and hints
2. **Directive Mode** - Machine-readable NUL-terminated directives for shell integration

The mode is determined at initialization in `main()` and never changes during execution.

### The Cardinal Rule: Never Check Mode in Command Code

**CRITICAL: Command code must NEVER check which output mode is active.**

The output system uses enum dispatch with a global context. Commands call output functions (`output::success()`, `output::change_directory()`, etc.) without knowing or caring which mode is active. The output system dispatches to the appropriate handler.

**Bad - mode conditionals scattered through commands:**
```rust
// ‚ùå NEVER DO THIS
use crate::output::OutputMode;

fn some_command(mode: OutputMode) {
    if mode == OutputMode::Interactive {
        println!("‚úÖ Success!");
    } else {
        println!("Success!\0");
    }
}
```

**Good - use the output system:**
```rust
// ‚úÖ ALWAYS DO THIS
use crate::output;

fn some_command() {
    output::success("Success!")?;
    // The output system handles formatting for both modes
}
```

### How It Works

The output system implements the "trust boundaries" principle:

1. **Decide once at the edge** - `main()` determines mode from CLI flags
2. **Initialize globally** - `output::initialize(mode)` sets up the handler
3. **Trust internally** - Commands just call output functions
4. **Dispatch handles adaptation** - Enum dispatch routes to appropriate handler

```rust
// In main.rs - the only place that knows about modes
let mode = if internal {
    OutputMode::Directive
} else {
    OutputMode::Interactive
};
output::initialize(mode);

// Everywhere else - just use the output functions
output::success("Created worktree")?;
output::change_directory(&path)?;
output::execute("git pull")?;
```

### Available Output Functions

The output module (`src/output/global.rs`) provides these functions:

- `success(message)` - Emit success messages (both modes)
- `progress(message)` - Emit progress updates (interactive only, suppressed in directive)
- `change_directory(path)` - Request directory change (directive) or store for execution (interactive)
- `execute(command)` - Execute command (interactive) or emit directive (directive mode)
- `command_output(stdout, stderr)` - Display output from external commands
- `flush()` - Flush output buffers

For the complete API, see `src/output/global.rs`.

### Adding New Output Functions

When adding new output capabilities:

1. **Add the function to both handlers** - `InteractiveOutput` and `DirectiveOutput`
2. **Add dispatch in global.rs** - Route to both handlers via enum match
3. **Never add mode parameters** - The handlers already know their mode

**Example: Adding a hypothetical `warning()` function**

This illustrates the pattern - follow these steps when adding any new output capability:

```rust
// In interactive.rs
impl InteractiveOutput {
    pub fn warning(&mut self, message: String) -> io::Result<()> {
        println!("{WARNING_EMOJI} {WARNING}{message}{WARNING:#}");
        Ok(())
    }
}

// In directive.rs
impl DirectiveOutput {
    pub fn warning(&mut self, message: String) -> io::Result<()> {
        // Warnings go to stderr in directive mode
        write!(io::stderr(), "{}\0", strip_str(&message))?;
        io::stderr().flush()
    }
}

// In global.rs
pub fn warning(message: impl Into<String>) -> io::Result<()> {
    OUTPUT_CONTEXT.with(|ctx| {
        let msg = message.into();
        match &mut *ctx.borrow_mut() {
            OutputHandler::Interactive(i) => i.warning(msg),
            OutputHandler::Directive(d) => d.warning(msg),
        }
    })
}
```

### Why This Matters

This architecture maintains the "one canonical path" principle from the global guidelines:

**Without this architecture**, you'd see:
- Mode conditionals scattered throughout 50+ command functions
- HIGH CARDINALITY: Two divergent code paths that must be kept in sync
- Mode parameters threading through the entire call stack
- Easy to forget one branch when changing behavior

**With this architecture**:
- Commands have ONE code path that works for both modes (LOW CARDINALITY)
- Mode-specific behavior encapsulated in two handler files
- Adding new commands requires zero mode awareness
- Changing behavior means updating one function, not hunting down 50+ conditionals

This is the same pattern as logging frameworks (`log`, `tracing`) - you configure once at startup, then the rest of the code just logs without caring where it goes.

### Red Flags and Solutions

**Red Flag: "I need to check if we're in interactive mode"**

This is always wrong. If you're tempted to check the mode, you have two options:

1. **The behavior should be the same in both modes** - Just do it directly, no check needed
2. **The behavior should differ between modes** - Add a new output function that encapsulates the difference

**Example scenario**: "I want to print a hint in interactive mode but not directive mode"

```rust
// ‚ùå DON'T DO THIS
if mode == OutputMode::Interactive {
    println!("üí° Use 'wt list' to see all worktrees");
}

// ‚úÖ DO THIS - progress() already handles this (shown in interactive, suppressed in directive)
output::progress("üí° Use 'wt list' to see all worktrees")?;
```

If the output function you need doesn't exist yet, follow the pattern in "Adding New Output Functions" above.

## Testing Guidelines

### Testing with --execute Commands

When testing commands that require confirmation (e.g., `wt switch --execute "..."`), use the `--force` flag to skip the interactive prompt:

```bash
# Good - skips confirmation prompt for testing
wt switch --create feature --execute "echo test" --force

# Bad - DO NOT pipe 'yes' to stdin, this crashes Claude
echo yes | wt switch --create feature --execute "echo test"
```

**Why `--force`?**
- Non-interactive testing requires automated approval
- Piping input to stdin interferes with Claude's I/O handling
- `--force` provides explicit, testable behavior
